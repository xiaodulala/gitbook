{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction welcome Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/":{"url":"golang/","title":"Golang","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/Golang编程规范和最佳实践.html":{"url":"golang/Golang编程规范和最佳实践.html","title":"Go语言编码规范和最佳实践","keywords":"","body":"概述 Go语言虽然简单易学，但是想要变成真正的编程个高手，写出易阅读，效率高，共享性和扩展性都比较优秀的高质量代码却是一件不简单的事情。 如何写出优雅且高质量的Go代码呢？ 遵循Go编码规范,这是最容易实现的途径。可以从Go社区中获取。比较受欢迎的是Uber Go 语言编码规范 学习并遵循前辈们探索沉淀下来的一些最佳实践。如 Effective Go：高效 Go 编程，由 Golang 官方编写，里面包含了编写 Go 代码的一些建议，也可以理解为最佳实践。 Go Code Review Comments：Golang 官方编写的 Go 最佳实践，作为 Effective Go 的补充。 本文是对这些规范和实践的一些总结。 编码规范 错误码规范 错误代码： 100101 10 服务 01 模块 01 模块下的错误码序号，每个模块可以注册 100 个错误 说明: 错误码用纯数字表示。每个部分分别代表服务 模块 错误码序号。每个模块可以注册100个错误。 Code 代码从 100101 开始。1000以下为保留code 通用错误设计如下： 服务 模块 说明 10 00 通用-基本错误 10 01 通用-数据库类错误 10 02 通用-认证授权类错误 10 03 通用-编码类错误 11 01 自己服务-用户模块错误 11 02 自己服务-xx模块错误 为什么这么设计: 如何设计一套合理的错误码 使用错误包: github.com/xiaodulala/component-tools/tree/main/pkg/errors 通用错误码引用：github.com/xiaodulala/component-tools/tree/main/component/errorcode 错误码注册工具和错误码文档生成工具: github.com/xiaodulala/component-tools/tree/main/tools/codegen 错误处理 error作为函数的返回值,必须对error进行处理。或将返回值赋值给明确忽略。对于defer xx.Close() 可以不用显示处理。 func load() error { // normal code } // bad load() // good _ = load() 如果一个函数返回了 value,error。你不能对这个value做任何假设，必须先判断error。唯一可以忽略error的是你连value都不关心。 error作为函数的值返回且有多个返回值的时候，error必须是最后一个参数。 尽早进行错误处理，并尽早返回，减少嵌套。 //bad if err!=nil{ //error code }else{ //normal code } //good if err!=nil{ return err } // normal code 错误描述建议 告诉用户他们可以做什么，而不是告诉他们不能做什么。 当声明一个需求时，用 must 而不是 should。例如，must be greater than 0、must match regex ‘[a-z]+’。 当声明一个格式不对时，用 must not。例如，must not contain。 当声明一个动作时用 may not。例如，may not be specified when otherField is empty、only name may be specified。 引用文字字符串值时，请在单引号中指示文字。例如，ust not contain ‘…’。 当引用另一个字段名称时，请在反引号中指定该名称。例如，must be greater than request。 指定不等时，请使用单词而不是符号。例如，must be less than 256、must be greater than or equal to 0 (不要用 larger than、bigger than、more than、higher than)。 指定数字范围时，请尽可能使用包含范围。 建议 Go 1.13 以上，error 生成方式为 fmt.Errorf(\"module xxx: %w\", err)。 错误描述用小写字母开头，结尾不要加标点符号，例如： // bad errors.New(\"Redis connection failed\") errors.New(\"redis connection failed.\") // good errors.New(\"redis connection failed\") 最佳实践 错误处理 错误只处理一次,打印日志也算一种错误处理。不要造成日志冗余。 func Bar()error{ _,err:=ioutil.ReadFile(\"./test.yaml\") if err!=nil{ log.Println(err) //bad return err } return nil } 在你的应用代码中,使用errors.new()或者errors.errorf返回错误 func parseArgs(args []string)error{ if len(args) 如果调用的是其他的函数，通常直接返回 err:=bar() if err!=nil{ return err } 如果调用的第三方库或者标准库的。考虑使用Warp或者Warpf保存堆栈信息。 func bar()error{ path:=\"./a.txt\" _,err:=os.Open(path) if err!=nil{ return errors.Wrapf(err,\"faild to open %q\",path) } return nil } 在程序的顶部或者是工作的 goroutine 顶部(请求入口)，使用 %+v 把堆栈详情记录。 func main() { err := app.Run() if err!=nil{ fmt.Printf(\"err:%+v\\n\",err) } } 使用error.Cause获取根错误再进行sentinel errror判断。或者直接使用Is函数。 选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同(kit 库的 sql.ErrNoRows)。 Packages that are reusable across many projects only return root error values. 如果你开发的是一个基础组件或者工具库。请返回确定的根错误值，不要返回包装错误。 一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零(比如降级处理中，你返回了降级数据，然后需要 return nil)。 Once an error is handled, it is not allowed to be passed up the call stack any longer. 参考引用 Rob Pike 所有关于 Go 的谚语 Uber Go 语言编码规范 孔令飞老师的极客时间的 Go语言项目实战 毛剑老师极客时间 Go进阶训练营 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/kernel/":{"url":"golang/kernel/","title":"Go语言核心","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/kernel/Go语言测试.html":{"url":"golang/kernel/Go语言测试.html","title":"Go语言如何测试","keywords":"","body":" 概述 在Go项目开发中,我们需要保证我们开发的模块功能稳定，且性能高效。所以我们要对我们自己的模块进行单元测试和性能测试。 在Go语言中，提供了Testing包来对我们的代码进行测试。 测试用例规范 测试用例文件必须以_test.go结尾。go test命令执行时会遍历当前包下所有的以_test.go文件作为测试用例源码文件。 测试用例函数必须以 Test、Benchmark、Example开头,后面直接跟函数名，函数名首字母需要大写。如：TestPrintHello。如果一个函数有多个测试用例,函数名称尽量表达出此函数的测试目的。 测试用例中变量命名规范: 测试用例中我们经常会定义输入和输出变量,最后比较输入和输出来判断测试用例是否通过。这两类变量通常定义为 expencted/actual或者是got/want。 单元测试 单元测试都是以Test开头。函数参数必须为 *test.T 如: func TestPrintHello(t *testing.T) { want := \"dy\" if got := PrintHello(\"dy\"); got != want { t.Errorf(\"want %s,bug got %s\", want, got) } } 这样的写法需要每次使用if比较输入和输出。我们可以使用github.com/stretchr/testify包来直接对比输入和输出。 func TestPrintHello(t *testing.T) { want := \"dy\" got := PrintHello(\"dy\") assert.Equal(t, want, got, \"values should be equal\") } 执行go test需要指定包路径,否则默认执行当前路径下的包的测试用例 # 以上测试用例执行 go test ./user go test -v参数,显示所有测试函数的运行细节。 go test -v ./user go test -run= 指定要指定的测试函数 go test -run=\"TestPrint.*\" go test -count=N 指定函数执行次数 go test -v -run=\"TestPrint.*\" -count=2 ./user 多输入测试用例 如果测试用例中要枚举多个输入进行测试。最好的方式是定义一个输出输出结构,遍历执行并对比结果: func TestPrintHelloMutil(t *testing.T) { tests := []struct { arg string want string }{ {arg: \"dy\", want: \"dy\"}, {arg: \"abc\", want: \"abc\"}, } for _, tt := range tests { got := PrintHello(tt.arg) assert.Equal(t, tt.want, got, \"values should be equal\") } } 自动生成单元测试代码 通过上面的示例我们大概了解,大部分的测试用例基本套路就是定义参数得到got。和之前的want做比较。这样就可以抽象出一个模型。 为了减少编写测试用例的时间,我们可以使用 gotests库来自动生成测试用例代码。这个库就是上面模型的实现。 安装工具 # go 生成测试用例代码 cd /users gotests -all -w . 补全代码 func TestNewUser(t *testing.T) { type args struct { name string age uint8 } tests := []struct { name string args args want *User wantErr bool }{ // TODO: Add test cases. {name: \"with all\", args: args{name: \"dy\", age: 20}, want: &User{Name: \"dy\", Age: 20}, wantErr: false}, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { got, err := NewUser(tt.args.name, tt.args.age) if (err != nil) != tt.wantErr { t.Errorf(\"NewUser() error = %v, wantErr %v\", err, tt.wantErr) return } if !reflect.DeepEqual(got, tt.want) { t.Errorf(\"NewUser() = %v, want %v\", got, tt.want) } }) } } 补全: // TODO: Add test cases. 性能测试 函数名称必须以Benchmark开头 参数必须是 Testing.B # b.N 为循环次数。N会在运行时自动调整。知道性能测试可以持续运行足够的时间。 func BenchmarkMax(b *testing.B) { for i := 0; i 运行性能测试函数 go test -bench=\".*\" ` # 输出 goos: darwin goarch: amd64 pkg: fuck_demo/user cpu: Intel(R) Core(TM) i5-5287U CPU @ 2.90GHz BenchmarkMax-4 315559854 3.681 ns/op PASS ok fuck_demo/user 2.086s # BenchmarkMax-4 4个cpu线程参与了此次测试。 # 315559854 循环了多少次。 # 3.681 ns/op 每次操作耗时 3.681纳秒。 需要注意,如果在性能测试函数中有一些耗时的初始化操作，这个时间不能计算在性能测试之内。所以需要重置性能计数。 func BenchmarkMax(b *testing.B) { // 耗时操作 fmt.Println(\"do something\") time.Sleep(time.Second * 1) b.ResetTimer() for i := 0; i # 显示使用内存信息 go test -bench=\".*\" -benchmem BenchmarkMax-4 323694256 3.678 ns/op 0 B/op 0 allocs/op # 0 B/op 每次执行分配了多少内存 # 0 allocs/op 每次执行分配了多少**次**内存 都是越少越好。 # 指定参与的cpu个数 go test -bench=\".*\" -GOMAXPROCS=2 # 指定测试时间(N)和循环次数(Nx) go test -bench=\".*\" -benchtime=10s 执行10秒 go test -bench=\".*\" -benchtime=100x 执行100次 # 指定测试超时时间 go test -bench=\".*\" -timeout=20s 示例测试 如果你写的模块需要被其他人调用。你可以在代码中写示例测试，用来演示你模块的使用方式。 示例测试一般保存在example_test.go文件中。 函数必须以Example开头，没有输入参数，没有返回值。 示例测试通过输出注释来判断测试是否通过.输出注释格式为 Output: 结果值 或者Unordered output:开头的注释 func ExampleFunc() { fmt.Println(strings.HasPrefix(\"_abc\", \"_\")) fmt.Println(math.Abs(-100)) // Output: // true // 100 } 示例函数命名规则 func Example() { ... } // 代表了整个包的示例 func ExampleF() { ... } // 函数F的示例 func ExampleT() { ... } // 类型T的示例 func ExampleT_M() { ... } // 方法T_M的示例 # 当一个函数 类型 或者方法有多个示例测试时 func ExampleReverse() func ExampleReverse_second() func ExampleReverse_third() 大型示例测试 通常在一个文件中。只用一个Example函数。 TestMain函数 主要用来做测试之前的准备工作和测试之后的清理工作。如连接数据库,清理临时文件等。 函数名必须是TestMain 参数必须是 *testing.M func TestMain(m *testing.M) { fmt.Println(\"do some stepup\") m.Run() fmt.Println(\"do some cleanup\") } Mock测试 在单元测试中,我们经常会碰到如下情况： 函数内部调用了数据库操作等外部依赖。 函数内部包含了一些未实现的调用。 此时,我们可以通过mock来处理。gomock是go官方提供的mock解决方案。 主要分为两部分: gomock库和mockgen gomock包用来完成对象生命周期的管理。 mockgen工具用来生成interface对应的mock类源文件。 安装 # gomock包下载 go get github.com/golang/mock/gomock # mockgen工具下载 go install github.com/golang/mock/mockgen@latest 示例 假设我们现在user中有一个函数是获取用户的微信UUID，但是此方法还没有实现。所以我们没有办法实现这个函数的测试用例。在这种情况下，我们就需要使用mock测试了。 # user.go func GetWechatUUID(wechater wechat.Wechater, name string) string { uuid := wechater.GetUUID(name) return uuid } # interface package wechat type Wechater interface { GetUUID(name string) string } 首先，使用mockgen工具,生成要mock的接口的实现。 mockgen -destination wechat/mock/mock_wechat.go -package mock_wechat fuck_demo/wechat Wechater # -destination: 存放mock类代码的文件。如果你没有设置这个选项，代码将被打印到标准输出 # -package: 用于指定mock类源文件的包名。如果你没有设置这个选项，则包名由mock_和输入文件的包名级联而成 # fuck_demo/wechat 是你接口所在的包 # Wechater 接口名称。可以是多个。用,分隔 使用mock文件,完成单元测试。 可以看到在指定路径下生成了mock_wechat.go文件。其中定义了一些函数和方法。这些方法用来支持我们编写单元测试。 // GetUUID indicates an expected call of GetUUID. func (mr *MockWechaterMockRecorder) GetUUID(arg0 interface{}) *gomock.Call { mr.mock.ctrl.T.Helper() return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetUUID\", reflect.TypeOf((*MockWechater)(nil).GetUUID), arg0) } # 单元测试中使用 func TestGetUUID(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() mockWechater := mock_wechat.NewMockWechater(ctrl) mockWechater.EXPECT().GetUUID(\"dy\").Return(\"dy\") got := GetWechatUUID(mockWechater, \"dy\") if got != \"dy\" { t.Errorf(\"get uuid fail\") } } 通过mock,不用我们自己去实现一个接口。降低了用例编写的复杂度。 mockgen的使用 源码模式 如果有接口文件,则通过源码模式来生成mock代码: mockgen -destination wechat/mock/mock_wechat.go -source wechat/wechat-interface.go # -source 要模拟的接口文件 反射模式 mockgen -destination wechat/mock/mock_wechat.go -package mock_wechat fuck_demo/wechat Wechater # 我们上面的示例用的是这种方式。 注释模式 如果要模拟的接口文件有多个，且分布在不同的文件中。我们需要对每个文件执行多次mockgen命令。mockgen 提供了一种通过注释生成mock文件的方式,需要借助go generate工具 在接口文件代码中,添加以下注释: //go:generate mockgen -destination mock/mock_wechat.go -package wechat fuck_demo/wechat Wechater type Wechater interface { GetUUID(name string) string } # 在命令行中执行 go generate ./... 使用mock代码编写单元测试 # 单元测试中使用 func TestGetUUID(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() mockWechater := mock_wechat.NewMockWechater(ctrl) mockWechater.EXPECT().GetUUID(\"dy\").Return(\"dy\") got := GetWechatUUID(mockWechater, \"dy\") if got != \"dy\" { t.Errorf(\"get uuid fail\") } } 创建mock控制器 defer 操作完之后回收。 使用控制器返回一个mock对象。 mock对象调用 gomock 支持以下参数匹配： gomock.Any()，可以用来表示任意的入参。 gomock.Eq(value)，用来表示与 value 等价的值。 gomock.Not(value)，用来表示非 value 以外的值。 gomock.Nil()，用来表示 None 值。 EXPECT()得到 Mock 的实例，然后调用 Mock 实例的方法，该方法返回第一个Call对象，然后可以对其进行条件约束，比如使用 Mock 实例的 Return 方法约束其返回值。Call对象还提供了以下方法来约束 Mock 实例： func (c *Call) After(preReq *Call) *Call // After声明调用在preReq完成后执行 func (c *Call) AnyTimes() *Call // 允许调用次数为 0 次或更多次 func (c *Call) Do(f interface{}) *Call // 声明在匹配时要运行的操作 func (c *Call) MaxTimes(n int) *Call // 设置最大的调用次数为 n 次 func (c *Call) MinTimes(n int) *Call // 设置最小的调用次数为 n 次 func (c *Call) Return(rets ...interface{}) *Call // // 声明模拟函数调用返回的值 func (c *Call) SetArg(n int, value interface{}) *Call // 声明使用指针设置第 n 个参数的值 func (c *Call) Times(n int) *Call // 设置调用次数为 n 次 fake测试 根据接口伪造一个实现接口的实例。 测试覆盖率 生成测试覆盖率数据 # 当前目录下所有文件全部提取,查看是否有对应的测试用例。生成测试覆盖率数据 go test -coverprofile=coverage.out ./... 分析覆盖率文件 go tool cover -func=coverage.out # 输出 fuck_demo/user/user.go:13: NewUser 100.0% fuck_demo/user/user.go:20: GetName 0.0% fuck_demo/user/user.go:24: SetAge 0.0% fuck_demo/user/user.go:29: PrintHello 0.0% fuck_demo/user/user.go:33: Max 0.0% fuck_demo/user/user.go:37: GetWechatUUID 100.0% total: (statements) 37.5% 生成html文件在浏览器查看 go tool cover -html=coverage.out -o coverage.html [!NOTE] 有时候代码测试覆盖率会作为准许合入分支的一项检查。如果覆盖率不足，会导致合入分支失败。我们可以使用go-junit-report 将覆盖率结构文件转换为xml,供其他CI系统使用。 [!WARNING] 使用mock生成的代码是不需要测试用例的，我们需要将生成的覆盖率文件中mock_*.go的文件去掉，否则会影响整体的测试覆盖率计算。 其他mock sqlmock 模拟数据库连接 httpmock 模拟http请求 bouk/monkey 猴子补丁,替换函数指针来修改任意函数的实现。mock最终解决方案。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/kernel/Go语言错误处理.html":{"url":"golang/kernel/Go语言错误处理.html","title":"Go语言错误处理","keywords":"","body":"Go中的error 在底层的实现中，error类型是一个普通的接口。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 所以，实现我们自己的错误类型非常容易。只要我们实现Error() string方法，这个方法的结构体都会被视为一个合法的错误值并可以被返回 type MyError struct { code int msg string } func (e *MyError)Error()string{ return fmt.Sprintf(\"code:%d,msg:%s\", e.code, e.msg) } func main() { err:= func1() fmt.Println(err) } func func1()error{ return &MyError{code: 1,msg: \"resource not found\"} } 内置的错误字符串(errorString)结构体 我们经常会使用errors.New(\"test err\")或者fmt.Errorf()来生成一个错误值。这个错误值的结构其实就是errorString。errorString实现了error接口的方法,所以可以当做一个合法的错误值。它做的事情就是保存一个string,并且由error接口返回。 package errors // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return &errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } errors不是异常(exceptions) 在其他语言中,exceptions机制各不相同。 c++中，你无法确定被调用者会抛出什么异常。而在java中，引入了checkd exception,方法的所有者必须申明可能会抛出哪些exception,而调用者必须处理。这样的话，java中的异常不再是异常，他们从良性到灾难性的都有，需要由调用者来判断。 go中明确了异常和错误的概念。异常就是程序出现不可预期的致命问题,无法再继续运行，引入panic机制。错误是可以预料的错误，是业务处理的中的一部分。这里使用的是error。 对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。 定义 错误的方式 sintinel error 预定义的特定错误，叫做 sintinel error。 这是我们经常使用的定义错误的方式。如标准库中的io.EOF。 使用预定义判断是最不灵活的错误处理策略。因为调用方必须使用 \"\\==\" 来比较预定义错误的值。当你想要提供更多的上下文时，就出现了一个问题，新增了上下文的错误会影响\"==\"检查 func main() { err:=bar() // 影响==判断 if err == simple.ErrorA{ fmt.Println(\"handler errorA\") } fmt.Println(err) } func bar()error{ err:=simple.SimpleA() if err!=nil{ // 增加了上下文信息 return fmt.Errorf(\"bar:%w\",err) } return nil } 不应该依赖检测error.Error()的输出。Error方法只是用来方便程序员输出字符串用来记录日志。而不应该被程序依赖(测试用例可能会用)。 预定义特定错误模式在两个包之间创建了源代码的依赖关系。例如检查错误是否等于io.EOF。你的代码必须导入io包。如果有很多包都需要导出各自的错误值。可能存在耦合。 所以我们应该尽量避免使用预定义特定错误的方式。 error types 实现 error interface接口的自定义错误类型。使用这种方式我们可以为错误信息增加更丰富的上下文信息。如标准库: type PathError struct { Op string Path string Err error } func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() } 但是在使用时,我们必须进行断言来判断是否是此错误: func main() { err:=pathErr() if err!=nil{ if _,ok:=err.(*fs.PathError);ok{ fmt.Println(\"handle path error\") } } // normal } func pathErr()error{ return &fs.PathError{ Op: \"create\", Path: \"/home/test\", Err: errors.New(\"filepath not found\"), } } 这种方式比sentinel方式好一些，因为它能可以捕获更多的上下文信息。但sentinel存在的一些问题依然没有得到解决。 为自定义错误增加特定的行为 net标准库 // An Error represents a network error. type Error interface { //扩展error接口。增加行为 error Timeout() bool // Is the error a timeout? Temporary() bool // Is the error temporary? } type UnknownNetworkError string func (e UnknownNetworkError) Error() string { return \"unknown network \" + string(e) } func (e UnknownNetworkError) Timeout() bool { return false } func (e UnknownNetworkError) Temporary() bool { return false } 在这种情况下,我们可以直接判断错误的行为。而不是去判断错误的类型或者值。我们也无需再再关注底层的err类型。 常见的error处理和存在的问题 在error中最常见的处理方式就是通过多值进行返回，明了的暴露出来，要么处理，要么略过。最常见的处理方式如下： func bar()error{ err:= foo() if err!=nil{ return fmt.Errorf(\"bar:%s\",err) } return nil } func foo()error{ err:= simple.SimpleA() if err!=nil{ return fmt.Errorf(\"foo:%s\",err) } return nil } 尽管我们通过fmt.Errorf的方式为错误增加了一些上下文信息，但还是不利于我们去排查错误。我们需要知道更多的错误信息: 在什么文件，在哪一行用来更好的定位。 错误处理最佳实践(github.com/pkg/errors) github.com/pkg/errors为我们封装了更加丰富的错误处理方式：保存错误堆栈信息、错误包装、格式化输出等功能。 几个重要结构和函数 fundamental 基本错误包含错误消息和堆栈信息，但是没有调用者。 // fundamental is an error that has a message and a stack, but no caller. type fundamental struct { msg string *stack } func main() { err1:=errors.New(\"new error\") err2:=errors.Errorf(\"new errorf\") fmt.Printf(\"%+v\\n\\n\",err1) //可以格式化输出 fmt.Printf(\"%+v\\n\\n\",err2) } withMessage 包装错误信息，但是不包含堆栈信息。 通过 WithMessage(err error, message string) error 和 WithMessagef(err error, format string, args ...interface{}) error函数来包装好的错误信息。 type withMessage struct { cause error msg string } func (w *withMessage) Error() string { return w.msg + \": \" + w.cause.Error() } func (w *withMessage) Cause() error { return w.cause } // Unwrap provides compatibility for Go 1.13 error chains. func (w *withMessage) Unwrap() error { return w.cause } func (w *withMessage) Format(s fmt.State, verb rune) { switch verb { case 'v': if s.Flag('+') { fmt.Fprintf(s, \"%+v\\n\", w.Cause()) io.WriteString(s, w.msg) return } fallthrough case 's', 'q': io.WriteString(s, w.Error()) } } func main() { err := foo() fmt.Printf(\"main err:%s\\n\\n\",err) fmt.Printf(\"main err:%v\\n\\n\",err) fmt.Printf(\"main err:%+v\\n\\n\",err) } func foo()error{ _,err:=ioutil.ReadFile(\"./test.yaml\") return errors.WithMessage(err,\"read file err\") } withStack 含有堆栈信息的错误包装。使用Wrap(err error, message string) error或者Wrapf(err error, format string, args ...interface{}) error type withStack struct { error // 这里的error其实是withMessage 堆栈信息是对withMessage的进一步封装 *stack } func (w *withStack) Cause() error { return w.error } // Unwrap provides compatibility for Go 1.13 error chains. func (w *withStack) Unwrap() error { return w.error } func (w *withStack) Format(s fmt.State, verb rune) { switch verb { case 'v': if s.Flag('+') { fmt.Fprintf(s, \"%+v\", w.Cause()) w.stack.Format(s, verb) return } fallthrough case 's': io.WriteString(s, w.Error()) case 'q': fmt.Fprintf(s, \"%q\", w.Error()) } } 获取错误根本原因 func foo()error{ _,err:=ioutil.ReadFile(\"./test.yaml\") return errors.Wrap(err,\"read file err\") } fmt.Println(\"main:\",errors.Cause(err)) // open ./test.yaml: no such file or directory 错误判断和解析 Is As Unwarp 从go 1.13以后,标准库采用了此包的错误处理方式。并添加了 Is As Unwap几个函数来更方便的处理错误。 此包为了兼容1.13,同时也增加了三个函数，内部都是调用的标准库函数。 func Is(err, target error) bool { return stderrors.Is(err, target) } func As(err error, target interface{}) bool { return stderrors.As(err, target) } func Unwrap(err error) error { return stderrors.Unwrap(err) } 由于错误采用包装的方式增加上下文信息并向上层传递。上层如果想要判断错误是否为某个具体错误,就不能直接用比较值的方式。Is方法用来将包装好的error剥开，并判断是否包装了目标错误。 func main() { err :=bar() if err!=nil{ if errors.Is(err,errFileNotFound){ fmt.Printf(\"%+v\\n\",err) } } } func bar()error{ return errors.WithMessage(foo(),\"bar\") } func foo()error{ return errFileNotFound } warp error的最佳实践 错误包装虽然可以方便我们处理错误,但也不能随意的进行包装，造成错误信息太过繁琐。这里对于错误的包装也有一些注意的地方 错误只处理一次,打印日志也算一种错误处理。不要造成日志冗余。 func Bar()error{ _,err:=ioutil.ReadFile(\"./test.yaml\") if err!=nil{ log.Println(err) //bad return err } return nil } 在你的应用代码中,使用errors.new()或者errors.errorf返回错误 func parseArgs(args []string)error{ if len(args) 如果调用的是其他的函数，通常直接返回 err:=bar() if err!=nil{ return err } 如果调用的第三方库或者标准库的。考虑使用Warp或者Warpf保存堆栈信息。 func bar()error{ path:=\"./a.txt\" _,err:=os.Open(path) if err!=nil{ return errors.Wrapf(err,\"faild to open %q\",path) } return nil } 在程序的顶部或者是工作的 goroutine 顶部(请求入口)，使用 %+v 把堆栈详情记录。 func main() { err := app.Run() if err!=nil{ fmt.Printf(\"err:%+v\\n\",err) } } 使用error.Cause获取根错误再进行sentinel errror判断。或者直接使用Is函数。 选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同(kit 库的 sql.ErrNoRows)。 Packages that are reusable across many projects only return root error values. 如果你开发的是一个基础组件或者工具库。请返回确定的根错误值，不要返回包装错误。 一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零(比如降级处理中，你返回了降级数据，然后需要 return nil)。 Once an error is handled, it is not allowed to be passed up the call stack any longer. go2错误处理 https://go.googlesource.com/proposal/+/master/design/29934-error-values.md Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/lib/":{"url":"golang/lib/","title":"Go语言三方库","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/lib/aa.html":{"url":"golang/lib/aa.html","title":"Test包","keywords":"","body":"aa aaaa bb aaaa [!NOTE] note...... aaaaaa [!TIP] tip....... aaaaa [!WARNING] warning..... aaaaaa [!DANGER] danger...... ccc aaaaa dddd ddddd bbbbbbbb Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/lib/命令行参数解析工具Pflag.html":{"url":"golang/lib/命令行参数解析工具Pflag.html","title":"命令行参数解析工具-pflag包","keywords":"","body":"概述 pflag是一个更加高级的命令行参数解析工具。pflag是一个完全兼容goflag的包。但其功能更加强大。按照POSIX/ gnu风格的 --flags实现。 在Go项目中，我们经常会在实现各种服务或者命令行工具时使用命令行参数解析来控制应用行为。Pflag包可以为我们提供更加方便的命令行参数解析。 Kubernetes、Helm、Docker、Etcd等项目使用的也是Pflag包来解析命令行参数的。 Pflag包安装 go get github.com/spf13/pflag Pflag包的使用 导入包 import flag \"github.com/spf13/pflag\" pflag.type()方式: 使用长选项的方式将标志解析到指针变量中。 可设置默认值和帮助信息. func main() { var ip *int = pflag.Int(\"flagname\", 123, \"help message for flagname\") pflag.Parse() fmt.Printf(\"%d\\n\", *ip) } ☁ pflagDemo ./main 123 ☁ pflagDemo ./main --flagname 234 234 ☁ pflagDemo ./main -h Usage of ./main: --flagname int help message for flagname (default 123) pflag: help requested pflag.typeVar()方式: 先声名接收变量，使用长选项的方式将falg的值绑定到指定的变量中。 var flagvar int var flagbool bool func main() { pflag.IntVar(&flagvar, \"flagname\", 1234, \"help message\") pflag.BoolVar(&flagbool, \"flagbool\", true, \"flagbool help message\") pflag.Parse() fmt.Printf(\"%v,%v\\n\", flagvar, flagbool) } ☁ pflagDemo ./main 1234,true ☁ pflagDemo ./main --flagbool=false --flagname 2345 2345,false pflag.typeP() 或者 pflag.typeVarP(). 在以上两种方式的基础上,增加命令行段选项支持。 func main() { var ip = pflag.IntP(\"flagname\", \"f\", 1234, \"help message\") var flagBool bool pflag.BoolVarP(&flagBool, \"boolname\", \"b\", true, \"help message\") pflag.Parse() fmt.Printf(\"%d,%v\\n\", *ip, flagBool) } ./main -b=false -f 3333 指定了选项，但是没有指定选项值的默认值 func main() { var ip = pflag.IntP(\"flagname\", \"f\", 1234, \"help message\") pflag.Lookup(\"flagname\").NoOptDefVal = \"4321\" pflag.Parse() fmt.Println(*ip) // ./main 输出 1234 使用默认值 // ./main -f 输出 4321 执行了选项,没有指定值。使用NoOptDefVal的值 // ./main -f=3333 输出 3333 } 命令行语法 --flag // boolean flags, or flags with no option default values --flag x // only on flags without a default value --flag=x # example1: bool类型的flag, 或者设置了 noOptDefVal的flag -f // ok true或者是noOptDefVal的值 -f=true -f=3333 // ok -f true // invalid -f 3333 // invalid //example2: 非bool类型的flag, 或者没有设置noOptDefVal的值 -n 1234 -n=1234 -n1234 都ok flag的\"规范化\" 允许自定义函数.让你的标志名称在代码中使用时更加规范化，且方便用于比较。在命令行中的输入与代码中的标志等价。 例子: func main() { fset := pflag.NewFlagSet(\"test\", pflag.ExitOnError) fset.SetNormalizeFunc(wordSepNormalizeFunc) } // You want -, _, and . in flags to compare the same. aka --my-flag == --my_flag == --my.flag func wordSepNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName { from := []string{\"-\", \"_\"} to := \".\" for _, sep := range from { name = strings.Replace(name, sep, to, -1) } return pflag.NormalizedName(name) } // You want to alias two flags. aka --old-flag-name == --new-flag-name func aliasNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName { switch name { case \"old-flag-name\": name = \"new-flag-name\" } return pflag.NormalizedName(name) } 弃用标志或者标志的简写 func main() { v := pflag.String(\"badflag\", \"hello\", \"help message\") v1 := pflag.IntP(\"flagname\", \"f\", 123, \"help message\") pflag.CommandLine.MarkDeprecated(\"badflag\", \"please use --good-flag instead\") pflag.CommandLine.MarkShorthandDeprecated(\"flagname\", \"please --flagname only\") pflag.Parse() println(*v, *v1) } # 不显示 badflag ./main -h Usage of ./main: --flagname int help message (default 123) # 可以用 badflag 但会出现提示 ./main --badflag world Flag --badflag has been deprecated, please use --good-flag instead # 使用flagname的短选项会有提示 ./main -f 100 Flag shorthand -f has been deprecated, please --flagname only 影藏标志 func main() { var adminAct string pflag.StringVar(&adminAct, \"admin\", \"admin\", \"help message\") pflag.CommandLine.MarkHidden(\"admin\") pflag.Parse() } 使用 help 无法看到admin 标识 pflag包数据结构 每个一个命令行参数都会被解析成一个pflag.Flag类型的变量 type Flag struct { Name string // flag长选项的名称 Shorthand string // flag短选项的名称，一个缩写的字符 Usage string // flag的使用文本 Value Value // flag的值 DefValue string // flag的默认值 Changed bool // 记录flag的值是否有被设置过 NoOptDefVal string // 当flag出现在命令行，但是没有指定选项值时的默认值 Deprecated string // 记录该flag是否被放弃 Hidden bool // 如果值为true，则从help/usage输出信息中隐藏该flag ShorthandDeprecated string // 如果flag的短选项被废弃，当使用flag的短选项时打印该信息 Annotations map[string][]string // 给flag设置注解 } Flag的值是一个Value类型的接口，Value的定义如下: type Value interface { String() string // 将flag类型的值转换为string类型的值，并返回string的内容 Set(string) error // 将string类型的值转换为flag类型的值，转换失败报错 Type() string // 返回flag的类型，例如：string、int、ip等 } Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/lib/配置文件解析工具viper.html":{"url":"golang/lib/配置文件解析工具viper.html","title":"配置文件解析工具-viper包","keywords":"","body":"概述 Vipier 是一个完整的Go应用程序配置文件解析方案。它可以处理任何类型或者格式的配置文件。 源码地址: viper Vipier支持: 设置默认值。 从不同格式的配置文件中读取配置包括json,toml,yaml,hcl,envfile. 从环境变量读取配置 从第三方配置存储服务读取配置 etcd consul并且监听配置改变。 从命令行参数选项中读取配置。 从本地缓冲中读取配置 直接设置值。 Vipie读取配置文件方式的顺序从高到底为: 直接使用 set的方式设置 命令行参数 环境变量 配置文件 kv存储 默认值 [!TIP] viper配置键不区分大小写。 使用 导入包 go get github.com/spf13/viper Viper使用方式。 viper中初始化了一个全局的vipier实例。所以我们可以在导入包后直接使用viper.set等方法设置配置值。我们可以在我们的应用中直接使用这个实例。 var v *Viper func init() { v = New() ...... } 设置默认值 func main() { viper.SetDefault(\"ContentDir\", \"content\") viper.SetDefault(\"LayoutDir\", \"layouts\") fmt.Println(viper.GetString(\"contentdir\")) //ok fmt.Println(viper.GetString(\"ContentDir\")) // ok } 从配置文件读取 func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") viper.AddConfigPath(\".\") viper.AddConfigPath(\"./config\") if err := viper.ReadInConfig(); err != nil { // 如果配置文件未找到的错误想被特殊处理 if _, ok := err.(viper.ConfigFileNotFoundError); ok { fmt.Println(\"config not found\") } else { fmt.Println(\"cofnig file cound but other errors\") panic(err) } } viper.SetDefault(\"app.name\", \"default\") fmt.Println(viper.GetString(\"app.name\")) //配置文件优先级高于默认值 fmt.Println(viper.GetStringSlice(\"app.databases\")) } 回写配置文件 一共有以下几种操作 WriteConfig 按照初始化的配置文件路径 回写配置。如果路径不存在，报错。文件存在则直接覆盖。 SafeWriteConfig 同上 路径不存在，报错。文件存在，不会覆盖。 WriteConfigAs 写入给定的文件路径下。如果文件存在，会覆盖 SafeWriteConfigAs 写入给定的文件路径下。如果文件存在，不会覆盖 不加AS,回写到viper.AddConfigPath(\".\")下的路径下。加AS,指定路径。加Safe,如果文件存在不覆盖。不加Safe，文件存在会覆盖。 //重新设置值 viper.Set(\"app.name\", \"gogogo\") //回写配置文件 viper.WriteConfig() // 回写到AddConfigPath路径中。 viper.SafeWriteConfig() viper.WriteConfigAs(\"./tpl/config.yaml\") viper.SafeWriteConfigAs(\"./tpl/config.yaml\") 配置文件热加载 func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") viper.AddConfigPath(\".\") viper.AddConfigPath(\"./config\") if err := viper.ReadInConfig(); err != nil { // 如果配置文件未找到的错误想被特殊处理 if _, ok := err.(viper.ConfigFileNotFoundError); ok { fmt.Println(\"config not found\") } else { fmt.Println(\"cofnig file cound but other errors\") panic(err) } } viper.WatchConfig() go func() { viper.OnConfigChange(func(e fsnotify.Event) { fmt.Println(e.Name) // Users/duyong/WorkPlace/goDemo/pflagDemo/config.yaml fmt.Println(e.Op) // WRITE fmt.Println(viper.GetString(\"app.name\")) }) }() select {} } 缓存中读取 viper.SetConfigType(\"yaml\") // or viper.SetConfigType(\"YAML\") // any approach to require this configuration into your program. var yamlExample = []byte(` Hacker: true name: steve hobbies: - skateboarding - snowboarding - go clothing: jacket: leather trousers: denim age: 35 eyes : brown beard: true `) viper.ReadConfig(bytes.NewBuffer(yamlExample)) viper.Get(\"name\") // this would be \"steve\" 读取环境变量 提供的方法： AutomaticEnv() BindEnv(string...) : error SetEnvPrefix(string) SetEnvKeyReplacer(string...) *strings.Replacer AllowEmptyEnv(bool) 在处理ENV变量时，重要的是要认识到Viper将ENV变量视为区分大小写的。 Viper提供了一种机制来尝试确保ENV变量是惟一的。通过使用SetEnvPrefix，可以告诉Viper在读取环境变量时使用前缀。BindEnv和AutomaticEnv都将使用这个前缀。 func main() { viper.SetEnvPrefix(\"viper\") // 自动转为大写 // 第一个参数为键名。只有第一个参数时,环境变量默认使用 前缀_大写键名 VIPER_USERNAME viper.BindEnv(\"username\") os.Setenv(\"VIPER_USERNAME\", \"jack\") fmt.Println(viper.Get(\"username\")) // 当有第二个参数时,第二个参数为显示指定的环境变量。就叫ID. viper.BindEnv(\"id\", \"ID\") os.Setenv(\"ID\", \"123\") fmt.Println(viper.Get(\"id\")) } func main() { os.Setenv(\"VIPER_USER_NAME\", \"jack\") os.Setenv(\"VIPER_USER_AGE\", \"20\") viper.AutomaticEnv() viper.SetEnvPrefix(\"VIPER\") // viper.get时 key中的. _ - 被替换为_ viper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\", \"-\", \"_\")) viper.BindEnv(\"user.name\") viper.BindEnv(\"user.age\", \"USER_AGE\") fmt.Println(viper.Get(\"user.name\")) fmt.Println(viper.Get(\"user.age\")) } 与Pflag绑定使用 func main() { // 绑定单个标志 port := pflag.Int(\"port\", 1138, \"Port to run Application server on\") viper.BindPFlag(\"port\", pflag.Lookup(\"port\")) pflag.Parse() fmt.Println(*port) } func main() { // 绑定标志集 port := pflag.Int(\"port\", 1138, \"Port to run Application server on\") viper.BindPFlags(pflag.CommandLine) pflag.Parse() fmt.Println(*port) } 从远程键值对数据库读取 viper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\") viper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" err := viper.ReadRemoteConfig() Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"golang/lib/命令行框架Cobra.html":{"url":"golang/lib/命令行框架Cobra.html","title":"命令行框架Cobra包","keywords":"","body":"概述 Cobra既是一个用于创建强大的现代CLI应用程序的库，也是一个用于生成应用程序和命令文件的程序。 cobra Cobra建立在commands(命令) arguments(参数) 和flags(标志)的结构之上。 好的应用程序被使用时就像在读一个句子。用户可以直观的知道如何使用他。一般有一下两种模式 APPNAME VERB NOUN --ADJECTIVE 或者 APPNAME COMMAND ARG --FLAG APPNAME 应用程序 VERB或者COMMAND 动词。程序要执行的操作。 NOUN或者ARG。 名词。非选项参数。可以代表操作作用的资源。 ADJECTIVE或者FALG。形容词。选项参数。操作资源的修饰符。 如: # server是cmd --port 是flag hugo server --port=1313 # clone是命令，url是选项参数 --bare是非选项参数 git clone URL --bare 安装 命令行安装 go install github.com/spf13/cobra/cobra@latest 安装库 go get -u github.com/spf13/cobra import \"github.com/spf13/cobra\" 目录结构 使用Cobra命令行工具时初始化的项目模板。同样在使用Cobra库时，我们最好也按照此模板来定义我们的目录格式。 ▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go package main import ( \"{pathToYourApp}/cmd\" ) func main() { cmd.Execute() } Cobra库的使用 手动实现Cobra命令框架时,我们需要一个main文件和rootcmd文件。你也可以根据自己的需要增加其他命令。 创建rootCmd 我们通常将rootCmd放在cmd/root.go中 var rootCmd = &cobra.Command{ Use: \"hugo\", Short: \"Hugo is a very fast static site generator\", Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // Do Stuff Here }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 我们可以通过viper和pflag(已经集成到cobra中)定义标志和配置绑定。 package cmd import ( \"fmt\" \"os\" homedir \"github.com/mitchellh/go-homedir\" \"github.com/spf13/cobra\" \"github.com/spf13/viper\" ) var rootCmd = &cobra.Command{ Use: \"hugo\", Short: \"Hugo is a very fast static site generator\", Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // Do Stuff Here }, } var ( cfgFile string projectBase string userLicense string ) func init() { cobra.OnInitialize(initConfig) rootCmd.PersistentFlags().StringVar(&cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobra.yaml)\") rootCmd.PersistentFlags().StringVarP(&projectBase, \"projectbase\", \"b\", \"\", \"base project directory eg. github.com/spf13/\") rootCmd.PersistentFlags().StringP(\"author\", \"a\", \"YOUR NAME\", \"Author name for copyright attribution\") rootCmd.PersistentFlags().StringVarP(&userLicense, \"license\", \"l\", \"\", \"Name of license for the project (can provide `licensetext` in config)\") rootCmd.PersistentFlags().Bool(\"viper\", true, \"Use Viper for configuration\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\")) viper.BindPFlag(\"projectbase\", rootCmd.PersistentFlags().Lookup(\"projectbase\")) viper.BindPFlag(\"useViper\", rootCmd.PersistentFlags().Lookup(\"viper\")) viper.SetDefault(\"author\", \"NAME HERE \") viper.SetDefault(\"license\", \"apache\") } func initConfig() { // Don't forget to read config either from cfgFile or from home directory! if cfgFile != \"\" { // Use config file from the flag. viper.SetConfigFile(cfgFile) } else { // Find home directory. home, err := homedir.Dir() if err != nil { fmt.Println(err) os.Exit(1) } // Search config in home directory with name \".cobra\" (without extension). viper.AddConfigPath(home) viper.SetConfigName(\".cobra\") } if err := viper.ReadInConfig(); err != nil { fmt.Println(\"Can't read config:\", err) os.Exit(1) } } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 添加命令 可以定义其他命令，并且通常在cmd/目录中给每个命令各自的文件 假设添加一个version命令 // cmd/version.go package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) var versionCmd = &cobra.Command{ Use: \"version\", Short: \"Print the version number of Hugo\", Long: `All software has versions. This is Hugo's`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Hugo Static Site Generator v0.9 -- HEAD\") }, } func init() { rootCmd.AddCommand(versionCmd) } 返回错误 使用RunE回调返回错误 var versionCmd = &cobra.Command{ Use: \"version\", Short: \"Print the version number of Hugo\", Long: `All software has versions. This is Hugo's`, RunE: func(cmd *cobra.Command, args []string) error { if err := someFunc(); err != nil { return err } return nil }, } func init() { rootCmd.AddCommand(versionCmd) } func someFunc() error { return errors.New(\"version cmd is invalid\") } 同Flag一起使用 Falg提供了修饰符来控制命令如何执行。 我们可以为命令分配标志。但是由于标Flag是在不同的位置定义和使用的，所以我们需要在外部定义一个具有正确作用域的变量，以便为标记赋值 持久标志 一个标志可以是'persistent'，这意味着这个标志将对它所分配的命令以及该命令下的每个命令可用。对于全局标志，在根上指定一个标志作为持久标志。 rootCmd.PersistentFlags().BoolVarP(&Verbose, \"verbose\", \"v\", false, \"verbose output\") 本地标志 也可以在本地分配标志，该标志将只应用于该特定的命令。 localCmd.Flags().StringVarP(&Source, \"source\", \"s\", \"\", \"Source directory to read from\") 父命令的本地标志 默认情况下，Cobra只解析目标命令上的本地标志，父命令上的任何本地标志都会被忽略。通过启用命令Command.TraverseChildren。Cobra将在执行目标命令之前解析每个命令的本地标志 command := cobra.Command{ Use: \"print [OPTIONS] [COMMANDS]\", TraverseChildren: true, } 同Vipier一起使用 var author string func init() { rootCmd.PersistentFlags().StringVar(&author, \"author\", \"YOUR NAME\", \"Author name for copyright attribution\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\")) } 在本例中，使用viper绑定持久标志author。注意:当user提供了——author标志时，变量author将不会被设置为config中的值。 标志必选 // 持久标志 rootCmd.PersistentFlags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkPersistentFlagRequired(\"region\") // 本地标志 rootCmd.Flags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkFlagRequired(\"region\") 非选项参数验证 在命令的过程中，经常会传入非选项参数，并且需要对这些非选项参数进行验证，Cobra 提供了机制来对非选项参数进行验证。可以使用 Command 的 Args 字段来验证非选项参数。Cobra 也内置了一些验证函数： NoArgs：如果存在任何非选项参数，该命令将报错。 ArbitraryArgs：该命令将接受任何非选项参数。 OnlyValidArgs：如果有任何非选项参数不在 Command 的 ValidArgs 字段中，该命令将报错。 MinimumNArgs(int)：如果没有至少 N 个非选项参数，该命令将报错。 MaximumNArgs(int)：如果有多于 N 个非选项参数，该命令将报错。 ExactArgs(int)：如果非选项参数个数不为 N，该命令将报错。 ExactValidArgs(int)：如果非选项参数的个数不为 N，或者非选项参数不在 Command 的 ValidArgs 字段中，该命令将报错。 RangeArgs(min, max)：如果非选项参数的个数不在 min 和 max 之间，该命令将报错。 var cmd = &cobra.Command{ Short: \"hello\", Args: func(cmd *cobra.Command, args []string) error { if len(args) 多个顶层命令例子 package main import ( \"fmt\" \"strings\" \"github.com/spf13/cobra\" ) func main() { var echoTimes int var cmdPrint = &cobra.Command{ Use: \"print [string to print]\", Short: \"Print anything to the screen\", Long: `print is for printing anything back to the screen. For many years people have printed back to the screen.`, Args: cobra.MinimumNArgs(1), Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Print: \" + strings.Join(args, \" \")) }, } var cmdEcho = &cobra.Command{ Use: \"echo [string to echo]\", Short: \"Echo anything to the screen\", Long: `echo is for echoing anything back. Echo works a lot like print, except it has a child command.`, Args: cobra.MinimumNArgs(1), Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Echo: \" + strings.Join(args, \" \")) }, } var cmdTimes = &cobra.Command{ Use: \"times [string to echo]\", Short: \"Echo anything to the screen more times\", Long: `echo things multiple times back to the user by providing a count and a string.`, Args: cobra.MinimumNArgs(1), Run: func(cmd *cobra.Command, args []string) { for i := 0; i 帮助选项和版本选项 如果在根命令上设置了version字段，Cobra会添加一个顶级的'——version'标志。使用'——version'标志运行应用程序将使用版本模板将版本打印到标准输出。模板可以通过cmd自定义。SetVersionTemplate(字符串)函数。 命令执行的钩子函数 在运行 Run 函数时，我们可以运行一些钩子函数，比如 PersistentPreRun 和 PreRun 函数在 Run 函数之前执行，PersistentPostRun 和 PostRun 在 Run 函数之后执行。如果子命令没有指定Persistent*Run函数，则子命令将会继承父命令的Persistent*Run函数。这些函数的运行顺序如下： PersistentPreRun PreRun Run PostRun PersistentPostRun package main import ( \"fmt\" \"github.com/spf13/cobra\" ) func main() { var rootCmd = &cobra.Command{ Use: \"root [sub]\", Short: \"My root command\", PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PersistentPreRun with args: %v\\n\", args) }, PreRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PreRun with args: %v\\n\", args) }, Run: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd Run with args: %v\\n\", args) }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PostRun with args: %v\\n\", args) }, PersistentPostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PersistentPostRun with args: %v\\n\", args) }, } var subCmd = &cobra.Command{ Use: \"sub [no options!]\", Short: \"My subcommand\", PreRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd PreRun with args: %v\\n\", args) }, Run: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd Run with args: %v\\n\", args) }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd PostRun with args: %v\\n\", args) }, PersistentPostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd PersistentPostRun with args: %v\\n\", args) }, } rootCmd.AddCommand(subCmd) rootCmd.SetArgs([]string{\"\"}) rootCmd.Execute() fmt.Println() rootCmd.SetArgs([]string{\"sub\", \"arg1\", \"arg2\"}) rootCmd.Execute() } 当“未知命令”发生时的建议 默认开启。如果要关闭执行: command.DisableSuggestions = true // 或者 command.SuggestionsMinimumDistance = 1 为命令生成文档 文档 简单使用 package main import ( \"log\" \"github.com/spf13/cobra\" \"github.com/spf13/cobra/doc\" ) func main() { cmd := &cobra.Command{ Use: \"test\", Short: \"my test program\", } err := doc.GenMarkdownTree(cmd, \"/tmp\") if err != nil { log.Fatal(err) } } 为整个命令树生成文档 package main import ( \"log\" \"io/ioutil\" \"os\" \"k8s.io/kubernetes/pkg/kubectl/cmd\" cmdutil \"k8s.io/kubernetes/pkg/kubectl/cmd/util\" \"github.com/spf13/cobra/doc\" ) func main() { kubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, ioutil.Discard, ioutil.Discard) err := doc.GenMarkdownTree(kubectl, \"./\") if err != nil { log.Fatal(err) } } shell自动补全 文档 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"design/":{"url":"design/","title":"架构知识积累","keywords":"","body":"Introduction 架构设计学习 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"design/微服务.html":{"url":"design/微服务.html","title":"微服务架构","keywords":"","body":"微服务与SOA的关系 SOA(Service Oriented Architecture) “面向服务的架构”。是一种设计架构的方法。其理念是每个服务以独立的形式存在于操作系统进程中。每个服务之间通过网络调用。 微服务架构: 微服务类似于SOA架构，可以看作是SOA架构的一种实现，同时也是升华。相比于SOA架构，微服务强调将服务更加的细化。将业务需要更彻底的组件化和服务化。使得业务系统拆分为可以独立开发、设计、运行的小应用。也就是微应用。这些小应用之间通过过程调用完成交互和集成。 微服务优缺点 微服务中的每个服务负责的都是单一的业务。符合架构设计的单一原则理念。微服务中的每个服务都是独立的进程,可以自动独立部署。服务间采用轻量级通信机制，可以使用不同的语言或者数据存储技术。通过使用容器编排技术 k8s等。使得服务以容器化的方式进行快速的，方便的隔离部署。 微服务从1个服务变成了多个服务。此时也会带来一些问题: 基础设施的建设复杂度变高。 解决或者跟踪问题的方式变得复杂。 必须手动处理服务之间远程调用过慢或者失败的问题。 微服务的每个服务都有自己的独立的数据库。会带来数据一致性的问题。 单个服务出问题时容易引起连锁反应导致整个服务不可用。 微服务如何落地 服务组件化 kit 一个微服务的基础库 service kit+业务代码+第三方依赖 rpc + message queue 去中心化 数据去中心化 每个服务独享自己的数据存储设置(缓存,数据库等) 治理去去中心化 技术去中心化 基础设施自动化 CI/CD 自动构建集成部署。 Testing 测试环境，单元测试，api测试 在线运行 k8s. 日志采集，报警。仪表盘等。 可用性和兼容性设计 对于可用性，要有Design For Failure思想。假设所有环节或者依赖都会失败来倒推你的设计。尽量采用粗粒度的的进程间通信(批量请求接口)。 隔离 超时控制 负载保护 限流 降级 重试 负载均衡 兼容性的设计要做到设计谨记保持服务契约(api)的兼容性Be conservative in what you send, be liberal in what you accept.发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守， 意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。 微服务如何设计 API网关的设计和演进 服务如何划分 按照公司部门或者模块划分。 DDD领域驱动设计的方式划分。 限界上下文是 DDD 中用来划分不同业务边界的元素， 这里业务边界的含义是“解决不同业务问题”的问题域 和对应的解决方案域，为了解决某种类型的业务问题， 贴近领域知识，也就是业务 CQRS 安全设计 服务外部： 网关鉴权。 限流熔断的操作。生成内部的token，传递到下一层BBF BBF 解析token 获取用户id 传递到服务层 服务层直接使用用户id 服务内部： full trust half trust zero trust 采用证书等方式实现服务的认证和授权。 服务发现 发现类型 客户端发现：直连，比服务端服务发现少一次网络跳转，Consumer 需要内置特定的服务发现客户端和发现逻辑。 服务端发现：Consumer 无需关注服务发现具体细节，只需知道服务的 DNS 域名即可，支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失。 通过 Family(appid) 和 Addr(IP:Port) 定位实例，除此之外还可以附加更多的元数据：权重、染色标签、集群等。 Provider 注册后定期(30s)心跳一次，注册， 心跳，下线都需要进行同步，注册和下线需要进行长轮询推送。 Consumer 启动时拉取实例，发起30s长轮询 Server 定期(60s) 检测失效(90s)的实例，失效则剔除。短时间里丢失了大量的心跳连接(15分钟内心跳低于期望值*85%)，开启自我保护，保留过期服务不删除。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"design/错误码.html":{"url":"design/错误码.html","title":"如何设计一套合理的错误码","keywords":"","body":"期望错误码实现的功能 RESTful API 是基于 HTTP 协议的一系列 API 开发规范，HTTP 请求结束后，无论 API 请求成功或失败，都需要让客户端感知到，以便客户端决定下一步该如何处理。 为了让用户拥有最好的体验，需要有一个比较好的错误码实现方式。在设计错误码时，我们希望能够实现以下功能： 每次返回不仅仅有HTTP Code码，还应该有业务Code码。 因为 HTTP Code 码有限，并且都是跟 HTTP Transport 层相关的 Code 码，所以我们希望能有自己的错误 Code 码。一方面，可以根据需要自行扩展，另一方面也能够精准地定位到具体是哪个错误。同时，因为 Code 码通常是对计算机友好的 10 进制整数，基于 Code 码，计算机也可以很方便地进行一些分支处理。当然了，业务码也要有一定规则，可以通过业务码迅速定位出是哪类错误。 考虑到安全，希望能够对外对内分别展示不同的错误信息。 当开发一个对外的系统，业务出错时，需要一些机制告诉用户出了什么错误，如果能够提供一些帮助文档会更好。但是，我们不可能把所有的错误都暴露给外部用户，这不仅没必要，也不安全。所以也需要能让我们获取到更详细的内部错误信息的机制，这些内部错误信息可能包含一些敏感的数据，不宜对外展示，但可以协助我们进行问题定位。 综上，我们需要设计的错误码应该是规范的，能方便客户端感知到 HTTP 是否请求成功，并带有业务码和出错信息 常见的错误码设计方式 假设错误消息为用户账号没有找到而请求失败的例子 不论请求成功或失败，始终返回200 http status code，在 HTTP Body 中包含用户账号没有找到的错误信息 例如 Facebook API 的错误 Code 设计，始终返回 200 http status code： { \"error\": { \"message\": \"Syntax error \\\"Field picture specified more than once. This is only possible before version 2.1\\\" at character 23: id,name,picture,picture\", \"type\": \"OAuthException\", \"code\": 2500, \"fbtrace_id\": \"xxxxxxxxxxx\" } } 采用固定返回200 http status code的方式，有其合理性。比如，HTTP Code 通常代表 HTTP Transport 层的状态信息。当我们收到 HTTP 请求，并返回时，HTTP Transport 层是成功的，所以从这个层面上来看，HTTP Status 固定为 200 也是合理的。 但是这个方式的缺点也很明显：对于每一次请求，我们都要去解析 HTTP Body，从中解析出错误码和错误信息。实际上，大部分情况下，我们对于成功的请求，要么直接转发，要么直接解析到某个结构体中；对于失败的请求，我们也希望能够更直接地感知到请求失败。这种方式对性能会有一定的影响，对客户端不友好。所以我不建议你使用这种方式。 返回http 400 错误码，并在 Body 中返回简单的错误信息。 例如：Twitter API 的错误设计，会根据错误类型，返回合适的 HTTP Code，并在 Body 中返回错误信息和自定义业务 Code。 HTTP/1.1 400 Bad Request x-connection-hash: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx set-cookie: guest_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Date: Thu, 01 Jun 2017 03:04:23 GMT Content-Length: 62 x-response-time: 5 strict-transport-security: max-age=631138519 Connection: keep-alive Content-Type: application/json; charset=utf-8 Server: tsa_b {\"errors\":[{\"code\":215,\"message\":\"Bad Authentication data.\"}]} 这种方式比第一种要好一些，通过http status code可以使客户端非常直接地感知到请求失败，并且提供给客户端一些错误信息供参考。但是仅仅靠这些信息，还不能准确地定位和解决问题。 返回http 400 错误码，并在 Body 中返回详细的错误信息。 例如：微软 Bing API 的错误设计，会根据错误类型，返回合适的 HTTP Code，并在 Body 中返回详尽的错误信息 HTTP/1.1 400 Date: Thu, 01 Jun 2017 03:40:55 GMT Content-Length: 276 Connection: keep-alive Content-Type: application/json; charset=utf-8 Server: Microsoft-IIS/10.0 X-Content-Type-Options: nosniff {\"SearchResponse\":{\"Version\":\"2.2\",\"Query\":{\"SearchTerms\":\"api error codes\"},\"Errors\":[{\"Code\":1001,\"Message\":\"Required parameter is missing.\",\"Parameter\":\"SearchRequest.AppId\",\"HelpUrl\":\"http\\u003a\\u002f\\u002fmsdn.microsoft.com\\u002fen-us\\u002flibrary\\u002fdd251042.aspx\"}]}} 推荐使用此种方式,既能通过http status code使客户端方便地知道请求出错，又可以使用户根据返回的信息知道哪里出错，以及如何解决问题。同时，返回了机器友好的业务 Code 码，可以在有需要时让程序进一步判断处理。 错误码设计建议 有区别于http status code的业务码，业务码需要有一定规则，可以通过业务码判断出是哪类错误。 请求出错时，可以通过http status code直接感知到请求出错。 需要在请求出错时，返回详细的信息，通常包括 3 类信息：业务 Code 码、错误信息和参考文档（可选） 。返回的错误信息，需要是可以直接展示给用户的安全信息，也就是说不能包含敏感信息；同时也要有内部更详细的错误信息，方便 debug。 返回的数据格式应该是固定的、规范的。 错误信息要保持简洁，并且提供有用的信息。 业务code码设计 在实际开发中，引入业务 Code 码有下面几个好处： 可以非常方便地定位问题和定位代码行（看到错误码知道什么意思、grep 错误码可以定位到错误码所在行、某个错误类型的唯一标识）。 错误码包含一定的信息，通过错误码可以判断出错误级别、错误模块和具体错误信息。 Go 中的 HTTP 服务器开发都是引用 net/http 包，该包中只有 60 个错误码，基本都是跟 HTTP 请求相关的错误码，在一个大型系统中，这些错误码完全不够用，而且这些错误码跟业务没有任何关联，满足不了业务的需求。引入业务的 Code 码，则可以解决这些问题。 推荐的 Code 码设计规范：纯数字表示，不同部位代表不同的服务，不同的模块。 错误代码说明：100101 10: 服务。 01: 某个服务下的某个模块。 01: 模块下的错误码序号，每个模块可以注册 100 个错误。 你可能会问：按这种设计，每个模块下最多能注册 100 个错误，是不是有点少？其实在我看来，如果每个模块的错误码超过 100 个，要么说明这个模块太大了，建议拆分；要么说明错误码设计得不合理，共享性差，需要重新设计。 设置对应的 HTTP Status Code Go net/http 包提供了 60 个错误码，大致分为如下 5 类： 1XX - （指示信息）表示请求已接收，继续处理。 2XX - （请求成功）表示成功处理了请求的状态代码。 3XX - （请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。 4XX - （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理，通常是客户端出错，需要客户端做进一步的处理。 5XX - （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是客户端的问题。 可以看到 HTTP Code 有很多种，如果每个 Code 都做错误映射，会面临很多问题。比如，研发同学不太好判断错误属于哪种http status code，到最后很可能会导致错误或者http status code不匹配，变成一种形式。而且，客户端也难以应对这么多的 HTTP 错误码。 所以，这里建议http status code不要太多，基本上只需要这 3 个 HTTP Code: 200 - 表示请求成功执行。 400 - 表示客户端出问题。 500 - 表示服务端出问题。 如果觉得这 3 个错误码不够用，最多可以加如下 3 个错误码： 401 - 表示认证失败。 403 - 表示授权失败。 404 - 表示资源找不到，这里的资源可以是 URL 或者 RESTful 资源。 将错误码控制在适当的数目内，客户端比较容易处理和判断，开发也比较容易进行错误码映射。 错误包的封装 好的错误包可以支持 错误堆栈 支持不通的格式 如%+v、%v、%s等格式，可以根据需要打印不同丰富度的错误信息。 能支持 Wrap/Unwrap 功能，也就是在已有的错误上，追加一些新的信息 支持Is As函数 能够支持两种错误创建方式：非格式化创建和格式化创建 github.com/pkg/errors/errors.go包支持以上功能并且已经被官方吸收到go的标准库中。 现在我们希望我们自己封装的错误包除了可以支持以上功能外，还可以支持记录业务错误码。 并在打印错误堆栈时，也同时打印我们自己的业务错误码。 github.com/xiaodulala/component-tools/tree/main/pkg/errors错误包 在github.com/pkg/errors/errors.go基础上修改，新增了withCode错误类型。并且维护了一个错误码字典。调用者可以将自己的错误码注册到内存中。 调用者可以按照规范定义错误码。以注释的方式标示错误码的对应httpCode和对外暴露的错误信息。然后通过工具 github.com/xiaodulala/component-tools/tree/main/tools/codegen自动生成注册代码，注册到错误包维护的内存字典中。 新的错误包维护的业务code字典主要用来打印错误堆栈时，在内存中寻找错误码对应的httpcode和对外错误信息。 为了方便错误码更加规范和通用，预先定义了一些通用的错误码，可以直接引入github.com/xiaodulala/component-tools/tree/main/component/errorcode. 这个包也同时演示了如何定义错误码和错误码的注释格式，然后用工具直接生成。 错误码规范 通过对错误码规范的一些分析。最终确定的错误码规范如下: 错误代码： 100101 10 服务 01 模块 01 模块下的错误码序号，每个模块可以注册 100 个错误 说明: 错误码用纯数字表示。每个部分分别代表服务 模块 错误码序号。每个模块可以注册100个错误。 Code 代码从 100101 开始。1000以下为保留code 通用错误设计如下： 服务 模块 说明 10 00 通用-基本错误 10 01 通用-数据库类错误 10 02 通用-认证授权类错误 10 03 通用-编码类错误 11 01 自己服务-用户模块错误 11 02 自己服务-xx模块错误 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"software/":{"url":"software/","title":"软件安装和使用","keywords":"","body":"Introduction 软件安装和使用篇 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"software/GitBook搭建并且关联到GitHub.html":{"url":"software/GitBook搭建并且关联到GitHub.html","title":"GitBook搭建并且关联到GitHub Pages","keywords":"","body":"概览 -- 记录一次使用gitbook写电子书,并且将源码推送到github仓库。最后通过github action自动构建电子书并且发布的过程。 最终效果: 本地编辑文章,生成md文件。push到github仓库，就可以在线通过自定义域名浏览文章。如: 我的笔记本 自动发布书籍的方式 我使用的是第二种方式,这里介绍一下两种方式 1. gitbook在线构建 gitbook 允许你使用md文档的语法，构建出精美的电子书。 gitbook是一个文档或者是电子书托管平台，官方站点就是 gitbook。是一个线上环境。 gitbook也是一个基于node.js的命令行工具。gitbook工具允许我们在本地快速构建书籍结构，下载插件，构建电子书并且支持启动本地web服务来浏览本地的电子书。 这里说一下使用gitbook线上环境自动发布书籍的逻辑: 首先gitbook线上环境允许你在线创建自己的文档,使用md的方式对文档进行编辑。 允许对外发布,分两种方式 1.允许搜索引擎爬取 2.不允许搜索引擎爬取。 对外发布的Space或者是Collection可以绑定自定义的域名,让用户访问。 在线的gitbook仓库也可以和github仓库关联,互相同步。 所以,如果使用gitbook线上环境自动发布书籍,可以这样做: 使用gitbook-cli创建本地书籍 登录gitbook账号,创建Space或者是Collection 创建你的github仓库,用来存储数据源文件。 gitbook仓库与github仓库绑定,授权同步。 这样我们就可以本地写文章,然后推送到github,绑定的仓库有更新时,gitbook会自动从github同步你的源文件。gitbook属于线上环境,会自动构建,安装插件。然后就可以访问了。 这是一种自动发布的方式,但自己的部署的时候碰到一些问题： 网站有时候不能访问，需要fq。 本地构建书籍时,插件可用。推送到线上后,gitbook构建出来的书籍格式很多插件没有被使用。导致书籍体验很不好。例如：目录插件不生效等...。目前还没发现哪里配置的有问题。 所以没有使用这种自动发布的方式,不使用gitbook在线环境，使用的是github的 pages。 2. github pages GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。 静态页面我们依然使用gitbook工具生成。然后按照以下步骤完成书籍自动发布: 安装gitbook工具,本地生成电子书。 安装一些gitbook插件,本地启动服务查看效果。 关联github仓库 创建github pages 使用github action自动构建电子书,并且发布到github pages github pages绑定自定义域名 这种自动发布方式与上面的方式不同点是: 我们相当于是将\"本地\"构建好的完整书籍项目推送到了gh-pages分支。而不是推送源码后在线上构建。 \"本地\"加了引号是因为，当我们使用了github action时, github会提供CI环境为我们进行构建并且将构建好的项目推送到指定分支。所以并不需要你真的每次都在本地构建,然后推送。其实,你每次推送的还是源码文件,剩下的全部都是自动执行。 GitBook命令工具 安装 npm install -g gitbook-cli gitbook -V gitbook ls # 按照提示装好版本 gitook命令使用 gitbook help # 查看帮助 gitbook init [book]。 初始化电子书。会在你指定目录下生成README和SUMMARY gitbook install 安装book.json指定的插件 gitbook build 构建书籍。生成的静态文件在_book中 gitbook serve 启动本地服务,查看电子书 # 还有一些导出书籍命令，可通过帮助文档查看。 书籍构建结构 这里介绍一下构建书籍的目录结构和文件说明 ├── .bookignore # gitbook忽略文件。主要用来指定 gitbook build时不打包到_book的文件 ├── .git ├── .github # github action 工作流目录 ├── .gitignore # 提交到github仓库忽略的文件 ├── README.md # 书籍介绍 ├── SUMMARY.md # 书籍目录 ├── _book # 构建出来的静态文件。此文件夹内就是我们要发布到pages的静态资源 ├── book.json # gitbook配置文件 ├── golang # 自定义的书籍目录 ├── img # 文章图片 ├── node_modules # 插件目录 └── sortware # 自定义的书籍目录 目录文件构建方式 # Summary * [Introduction](README.md) * [Golang](golang/README.md) * [Go语言核心](golang/kernel/README.md) * [Go语言如何测试](golang/kernel/Go语言测试.md) * [Go语言三方库](golang/lib/README.md) * [Test包](golang/lib/aa.md) * [Go经典面试题](golang/question/README.md) * [软件安装和使用](software/README.md) * [GitBook搭建并且关联到GitHub Pages](software/GitBook搭建并且关联到GitHub.md) 每个文件件下要有自己的README文件。 目录文件夹下不能再有目录。不支持书籍嵌套。 插件配置 \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"expandable-chapters-small\", \"code\", \"copy-code-button\", \"-lunr\", \"-search\", \"search-pro\", \"advanced-emoji\", \"github\", \"splitter\", \"page-toc-button\", \"alerts\", \"flexible-alerts\", \"pageview-count\", \"auto-scroll-table\", \"popup\", \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com\" }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy Du Yong \", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 } } 插件可以参考这边文章 GitBook插件整理 github pages配置 官网介绍 关于 GitHub Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。 您可以在 GitHub Pages 示例集合中查看 GitHub Pages 站点的示例。 站点类型: 组织 要发布组织站点，必须创建名为 .github.io 的组织所拥有的仓库 用户 要发布用户站点，必须创建用户帐户所拥有的名为 .github.io 项目 项目站点源文件和项目本身存储在一个仓库中。在不使用自定义域名的情况下,项目站点访问http(s)://.github.io/ 我采用项目站点类型。因为项目站点可以有多个。而个人或者组织站点只能有一个。 新建仓库 gitbook-note 关联本地仓库 git init git remote add origin git@github.com:xiaodulala/gitbook-note.git # 推送到github仓库 注意,要将_book node_modules两个文件夹的内容忽略掉。只提交书籍的源文件。不要提交构建出来的静态资源文件和下载的插件。 git push origin master 构建书籍 # 使用build 构建书籍。默认目录为_book. 注意我们不希望构建出来的静态目录有一些其他的文件。要选择忽略掉。 编写.bookignore 忽略一些文件： .gitignore .github .bookignore #构建 gitbook build 创建远程分支gh-pages分支.并与本地静态资源仓库matser分支关联 cd _book git init git remote add origin git@github.com:xiaodulala/gitbook-note.git git push --force --quiet \"git@github.com:xiaodulala/gitbook-note.git\" master:gh-pages 以上操作后,我们可以在仓库设置中的page页面查看访问地址。 到目前为止,是我们手动构建的。接着要把构建并发布自动化。使用github actions. github actions配置 github actions 是github上用来持续集成和部署的功能。 每次持续继承偶读需要拉取代码、跑测试用例、合并分支、服务部署和发布等操作。github就把这些操作称为actions. github允许开发者把每个操作写成独立的脚本，存放到代码仓库里。供其他人引用。所以，当我们的项目需要使用github actions时，就不需要编写复杂的从0开始的脚本。我们可以直接引用别人写好的actions. github actions 官方市场 gitbook的发布我选用了 这一个插件。 工作流文件如下: name: Build and Publish My GitBook on: workflow_dispatch: push: branches: - master jobs: build: name: Build Gitbook runs-on: ubuntu-latest steps: # Check out the repo first - name: Checkout code uses: actions/checkout@v2 # Run this action to publish gitbook - name: Publish uses: tuliren/publish-gitbook@v1.0.0 with: # specify either github_token or personal_token github_token: ${{ secrets.GITHUB_TOKEN }} # personal_token: ${{ secrets.PERSONAL_TOKEN }} 这样，我们就可以在本地推送源文件后，自动发布了。你可以在github的action选项中查看构建过程和结果。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"software/docker&docker-compose安装.html":{"url":"software/docker&docker-compose安装.html","title":"docker&docker-compose安装","keywords":"","body":"[TOC] docker 安装 根据操作系统安装(需提供外网)官方文档: docker安装 centos # 1.卸载 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2. Enable the nightly or test repositories. sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum-config-manager --enable docker-ce-nightly sudo yum-config-manager --enable docker-ce-test # 3. 查看版本 安装 yum list docker-ce --showduplicates | sort -r sudo yum install docker-ce- docker-ce-cli- containerd.io # sudo yum install docker-ce docker-ce-cli containerd.io 安装最新 # 4. 启动 sudo systemctl start docker sudo systemctl enable docker # 5. 验证 sudo docker run hello-world ubuntu # 1. 卸载 sudo apt-get remove docker docker-engine docker.io containerd runc # 2. Set up the repository sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release # Add Docker’s official GPG key: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # To add the nightly or test repository echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null # 3. 版本列表 安装 sudo apt-get update apt-cache madison docker-ce sudo apt-get install docker-ce= docker-ce-cli= containerd.io # sudo apt-get install docker-ce docker-ce-cli containerd.io 最新版本 # 4. 验证 sudo docker run hello-world Manage Docker as a non-root user # 1. Create the docker group. sudo groupadd docker # 2.Add your user to the docker group. sudo usermod -aG docker $USER # 3. Log out and log back in so that your group membership is re-evaluated. newgrp docker Configure Docker to start on boot sudo systemctl enable docker.service sudo systemctl enable containerd.service 加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json docker-compose 安装 二进制下载 脚本安装 sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 卸载 sudo yum remove docker-ce docker-ce-cli containerd.io sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 问题 centos 3.10.0-229.7.2.el7.x86_64 这个版本 只要安装最新的docker,端口映射无法访问。 安装旧版本 sudo yum -y --downloadonly update sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sudo yum -y install docker-ce-18.03.1.ce # 剩下都一样 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"software/docker-compose安装软件.html":{"url":"software/docker-compose安装软件.html","title":"docker-compose启动应用","keywords":"","body":"Mysql 创建目录 # 创建目录 mkdir -p mysql/datadir mysql/conf mysql/mydir Mysql配置文件 vim ./mysql/conf/my.cnf [mysqld] user=mysql default-storage-engine=INNODB #character-set-server=utf8 character-set-client-handshake=FALSE character-set-server=utf8mb4 collation-server=utf8mb4_unicode_ci init_connect='SET NAMES utf8mb4' # 主从时使用 server_id=1 # 开启binlog 按需开启。影响性能 log-bin=mysql-bin # 行模式(5.7默认) binlog_format=row # binlog同步事务数(5.7默认) sync_binlog=1 skip-grant-tables [client] #utf8mb4字符集可以存储emoji表情字符 #default-character-set=utf8 default-character-set=utf8mb4 [mysql] #default-character-set=utf8 default-character-set=utf8mb4 docker-compose.yaml version: '3' services: dy_mysql: restart: always image: mysql:5.7 container_name: dy_mysql volumes: - ./mydir:/mydir - ./datadir:/var/lib/mysql - ./conf/my.cnf:/etc/my.cnf environment: - MYSQL_ROOT_PASSWORD=duyong - TZ=Asia/Shanghai ports: - 3306:3306 修改密码 # 进入容器 docker exec -it dy_mysql bash # 进入mysql mysql # 修改密码 mysql>update mysql.user set authentication_string=password('duyong') where user='root'; # 允许root远程连接(看需要设置) grant all privileges on *.* to 'root'@'%' identified by 'duyong' with grant option; flush privileges; # 退出容器 删除配置中的skip-grant-tables 重启容器 Postgres + pgadmin4 创建目录 mkdir -p postgres/data docker-compose.yaml version: '3.1' services: postgres: container_name: duyong_postgres image: postgres:12.9 restart: always environment: POSTGRES_USER: root POSTGRES_PASSWORD: root POSTGRES_DB: duyong ports: - 5432:5432 volumes: - ./data:/var/lib/postgresql/data pgadmin4: container_name: duyong_pgadmin4 image: dpage/pgadmin4 restart: always environment: PGADMIN_DEFAULT_EMAIL: admin@fskj.com PGADMIN_DEFAULT_PASSWORD: 123 ports: - 18080:80 zookeeper单机集群 创建目录 mkdir -p zk docker-compose.yaml version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 查看集群状态 # 进入容器 docker exec -it zk-single_zoo1_1 bash # ./bin/zkServer.sh status Using config: /conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: follower zookeeper多机集群 机器 节点 ip zk node1 10.0.0.99 zk1 node2 10.0.0.100 zk2 node3 10.0.0.101 zk3 分别创建目录 # 99 mkdir -p zk1 #100 mkdir -p zk2 #101 mkdir -p zk3 docker-compose.yaml # 10.0.0.99 version: '3.1' services: zoo: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=10.0.0.100:2888:3888;2181 server.3=10.0.0.101:2888:3888;2181 # 10.0.0.100 version: '3.1' services: zoo: image: zookeeper restart: always hostname: zoo2 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=10.0.0.99:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=10.0.0.101:2888:3888;2181 # 10.0.0.101 version: '3.1' services: zoo: image: zookeeper restart: always hostname: zoo3 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=10.0.0.99:2888:3888;2181 server.2=10.0.0.100:2888:3888;2181 server.3=zoo3:2888:3888;2181 ZK+Kafka单机集群 创建资源目录 mkdir -p kafka-single docker-compose.yaml version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 kafka1: image: wurstmeister/kafka restart: always hostname: kafka1 container_name: kafka1 ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka1 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2182,zoo3:2183 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka1:9092 KAFKA_LISTENERS: PLAINTEXT://kafka1:9092 volumes: - ./kafka1/logs:/kafka kafka2: image: wurstmeister/kafka restart: always hostname: kafka2 container_name: kafka2 ports: - 9093:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2182,zoo3:2183 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka2:9092 KAFKA_LISTENERS: PLAINTEXT://kafka2:9092 volumes: - ./kafka2/logs:/kafka kafka3: image: wurstmeister/kafka restart: always hostname: kafka3 container_name: kafka3 ports: - 9094:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka3 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2182,zoo3:2183 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka3:9092 KAFKA_LISTENERS: PLAINTEXT://kafka3:9092 volumes: - ./kafka3/logs:/kafka 测试集群 # 生产者 docker exec -it kafka1 bash # 创建topic kafka-topics.sh --create --zookeeper 10.0.0.99:2181 --replication-factor 1 --partitions 1 --topic test1 # 容器1发送消息 kafka-console-producer.sh --broker-list 10.0.0.99:9092 --topic test1 # 进入kakfa2容器查看消息 docker exec -it kafka2 bash kafka-console-consumer.sh --bootstrap-server 10.0.0.99:9092 --topic test1 --from-beginning Kafka多机集群 和多机zk配合使用 # 10.0.0.99 version: '3.1' services: kafka1: image: wurstmeister/kafka restart: always hostname: kafka1 container_name: kafka1 ports: - 9092:9092 environment: KAFKA_BROKER_ID: 1 KAFKA_ADVERTISED_HOST_NAME: 10.0.0.99 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: 10.0.0.99:2181,10.0.0.100:2181,10.0.0.101:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://10.0.0.99:9092 KAFKA_LISTENERS: PLAINTEXT://kafka1:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 3 volumes: - ./logs:/kafka # 10.0.0.100 version: '3.1' services: kafka2: image: wurstmeister/kafka restart: always hostname: kafka2 container_name: kafka2 ports: - 9092:9092 environment: KAFKA_BROKER_ID: 2 KAFKA_ADVERTISED_HOST_NAME: 10.0.0.100 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: 10.0.0.99:2181,10.0.0.100:2181,10.0.0.101:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://10.0.0.100:9092 KAFKA_LISTENERS: PLAINTEXT://kafka2:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 3 volumes: - ./logs:/kafka # 10.0.0.101 version: '3.1' services: kafka3: image: wurstmeister/kafka restart: always hostname: kafka3 container_name: kafka3 ports: - 9092:9092 environment: KAFKA_BROKER_ID: 3 KAFKA_ADVERTISED_HOST_NAME: 10.0.0.101 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: 10.0.0.99:2181,10.0.0.100:2181,10.0.0.101:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://10.0.0.101:9092 KAFKA_LISTENERS: PLAINTEXT://kafka3:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 3 volumes: - ./logs:/kafka Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "},"software/数据源实时同步中间件之canal和Maxwell.html":{"url":"software/数据源实时同步中间件之canal和Maxwell.html","title":"数据源实时同步中间件之canal和Maxwell","keywords":"","body":"介绍 数据实时同步有很多种方法,其中一种叫CDC。 CDC(Change Data Capture)是变更数据捕获简称。这种方法可以基于增量日志，以极低的侵入性完成增量数据捕获的工作。核心思想是: 监测并捕获数据库的变动(包括数据或者数据表的插入、更新、以及删除等)。将这些变更按照发生的顺序完成记录下来,写入到消息中间件以供其他服务进行订阅和消费。 简单来讲：CDC是指从源数据库捕获到数据和数据结构(也称为模式)的增量变更，近乎实时地将这些变更，传播到其他数据库或应用程序之处。 通过这种方式，CDC能够向数据仓库提供高效、低延迟的数据传输，以便信息被及时转换并交付给专供分析的应用程序。 与批量复制相比，变更数据的捕获通常具有如下优势: CDC通过仅发送增量的变更，来降低通过网络传输数据的成本。 CDC可以帮助用户根据最新的数据做出更快、更准确的决策。例如，CDC会将事务直接传输到专供分析的应用上。 CDC最大限度地减少了对于生产环境网络流量的干扰。 CDC中间件工具对比 目前常用的工具有如下几种: 特色 Canal Maxwell mysql_staram go-mysql-transfer 开发语言 java(阿里) java(外国) python golang 活跃度 活跃 活跃 - - 高可用 支持 支持(断点还原功能) 支持 支持 数据落地 定制 Kafka，Kinesis、RabbitMQ、Redis、Go ogle Cloud Pub/Sub、文件等) Kafka等(MQ) Redis、MongoDB、Elasticsearch、RabbitMQ、Kafka、RocketMQ、HTTP API 等 分区 支持 支持 - - 引导 不支持 支持 - - 数据格式 定制 json json json 文档 详细 详细 - - 现在用的最多的工具为canal和maxwell. 其他两种工具需要继续调研。 canalmaxwell canal属于比较重。服务端需要一个客户端来配合使用。需要用户自己定制的数据落地方式和数据格式方式。自由的同时也增加了开发量。 maxwell 属于轻量级的服务。服务端+客户端为一体。高可用的方式使用的是断点还原的方法。并且支持数据引导。 可以根据不同的应用场景进行选择。如果不是非常大型的并且定制化要求很高的服务。推荐使用maxwell Maxwell的使用 配置Mysql 修改配置文件 [mysqld] server_id=1 log-bin=master binlog_format=row sync_binlog=1 验证 mysql> show variables like \"%binlog%\"; mysql> show variables like '%server_id%'; mysql> show variables like '%log_bin%'; 创建maxwell用户并赋予权限。主要用来记录binlog同步点。 mysql> CREATE USER 'maxwell'@'%' IDENTIFIED BY 'duyong'; mysql> GRANT ALL ON maxwell.* TO 'maxwell'@'%'; mysql> GRANT SELECT, REPLICATION CLIENT, REPLICATION SLAVE ON *.* TO 'maxwell'@'%'; mysql> flush privileges; 启动测试的maxwell 测试 docker run -it --rm zendesk/maxwell bin/maxwell --user=maxwell\\ --password=duyong --host=10.0.0.99 --producer=stdout docker run -it --rm zendesk/maxwell bin/maxwell --user=maxwell\\ --password=duyong --host=10.0.0.100 --producer=stdout 安装kafka集群 docker 安装zookeeper集群 # 10.0.0.99 version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=10.0.0.100:2888:3888;2181 server.3=10.0.0.101:2888:3888;2181 # 10.0.0.100 version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo2 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=10.0.0.99:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=10.0.0.101:2888:3888;2181 # 10.0.0.101 version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo3 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=10.0.0.99:2888:3888;2181 server.2=10.0.0.100:2888:3888;2181 server.3=zoo3:2888:3888;2181 docker 安装kafka集群 docker-compose启动应用 docker启动maxwell并使用kafka docker run -it --rm zendesk/maxwell bin/maxwell --user=maxwell\\ --password=duyong --host=10.0.0.99 --producer=kafka \\ --kafka.bootstrap.servers=10.0.0.99:9092,10.0.0.100:9092,10.0.0.101:9092 --kafka_topic=maxwell # 后台启动 docker run -itd zendesk/maxwell bin/maxwell --user=maxwell\\ --password=duyong --host=10.0.0.99 --producer=kafka \\ --kafka.bootstrap.servers=10.0.0.99:9092,10.0.0.100:9092,10.0.0.101:9092 --kafka_topic=maxwell docker run -it --rm zendesk/maxwell bin/maxwell --user=maxwell\\ --password=duyong --host=10.0.0.100 --producer=kafka \\ --kafka.bootstrap.servers=10.0.0.99:9092,10.0.0.100:9092,10.0.0.101:9092 --kafka_topic=maxwell # 后台启动 docker run -itd zendesk/maxwell bin/maxwell --user=maxwell\\ --password=duyong --host=10.0.0.100 --producer=kafka \\ --kafka.bootstrap.servers=10.0.0.99:9092,10.0.0.100:9092,10.0.0.101:9092 --kafka_topic=maxwell Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-01-19 10:44:43 "}}