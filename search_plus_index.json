{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction welcome Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/":{"url":"golang/","title":"Golang","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/kernel/":{"url":"golang/kernel/","title":"Go语言核心","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/kernel/Go语言测试.html":{"url":"golang/kernel/Go语言测试.html","title":"Go语言如何测试","keywords":"","body":" 概述 在Go项目开发中,我们需要保证我们开发的模块功能稳定，且性能高效。所以我们要对我们自己的模块进行单元测试和性能测试。 在Go语言中，提供了Testing包来对我们的代码进行测试。 测试用例规范 测试用例文件必须以_test.go结尾。go test命令执行时会遍历当前包下所有的以_test.go文件作为测试用例源码文件。 测试用例函数必须以 Test、Benchmark、Example开头,后面直接跟函数名，函数名首字母需要大写。如：TestPrintHello。如果一个函数有多个测试用例,函数名称尽量表达出此函数的测试目的。 测试用例中变量命名规范: 测试用例中我们经常会定义输入和输出变量,最后比较输入和输出来判断测试用例是否通过。这两类变量通常定义为 expencted/actual或者是got/want。 单元测试 单元测试都是以Test开头。函数参数必须为 *test.T 如: func TestPrintHello(t *testing.T) { want := \"dy\" if got := PrintHello(\"dy\"); got != want { t.Errorf(\"want %s,bug got %s\", want, got) } } 这样的写法需要每次使用if比较输入和输出。我们可以使用github.com/stretchr/testify包来直接对比输入和输出。 func TestPrintHello(t *testing.T) { want := \"dy\" got := PrintHello(\"dy\") assert.Equal(t, want, got, \"values should be equal\") } 执行go test需要指定包路径,否则默认执行当前路径下的包的测试用例 # 以上测试用例执行 go test ./user go test -v参数,显示所有测试函数的运行细节。 go test -v ./user go test -run= 指定要指定的测试函数 go test -run=\"TestPrint.*\" go test -count=N 指定函数执行次数 go test -v -run=\"TestPrint.*\" -count=2 ./user 多输入测试用例 如果测试用例中要枚举多个输入进行测试。最好的方式是定义一个输出输出结构,遍历执行并对比结果: func TestPrintHelloMutil(t *testing.T) { tests := []struct { arg string want string }{ {arg: \"dy\", want: \"dy\"}, {arg: \"abc\", want: \"abc\"}, } for _, tt := range tests { got := PrintHello(tt.arg) assert.Equal(t, tt.want, got, \"values should be equal\") } } 自动生成单元测试代码 通过上面的示例我们大概了解,大部分的测试用例基本套路就是定义参数得到got。和之前的want做比较。这样就可以抽象出一个模型。 为了减少编写测试用例的时间,我们可以使用 gotests库来自动生成测试用例代码。这个库就是上面模型的实现。 安装工具 # go 生成测试用例代码 cd /users gotests -all -w . 补全代码 func TestNewUser(t *testing.T) { type args struct { name string age uint8 } tests := []struct { name string args args want *User wantErr bool }{ // TODO: Add test cases. {name: \"with all\", args: args{name: \"dy\", age: 20}, want: &User{Name: \"dy\", Age: 20}, wantErr: false}, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { got, err := NewUser(tt.args.name, tt.args.age) if (err != nil) != tt.wantErr { t.Errorf(\"NewUser() error = %v, wantErr %v\", err, tt.wantErr) return } if !reflect.DeepEqual(got, tt.want) { t.Errorf(\"NewUser() = %v, want %v\", got, tt.want) } }) } } 补全: // TODO: Add test cases. 性能测试 函数名称必须以Benchmark开头 参数必须是 Testing.B # b.N 为循环次数。N会在运行时自动调整。知道性能测试可以持续运行足够的时间。 func BenchmarkMax(b *testing.B) { for i := 0; i 运行性能测试函数 go test -bench=\".*\" ` # 输出 goos: darwin goarch: amd64 pkg: fuck_demo/user cpu: Intel(R) Core(TM) i5-5287U CPU @ 2.90GHz BenchmarkMax-4 315559854 3.681 ns/op PASS ok fuck_demo/user 2.086s # BenchmarkMax-4 4个cpu线程参与了此次测试。 # 315559854 循环了多少次。 # 3.681 ns/op 每次操作耗时 3.681纳秒。 需要注意,如果在性能测试函数中有一些耗时的初始化操作，这个时间不能计算在性能测试之内。所以需要重置性能计数。 func BenchmarkMax(b *testing.B) { // 耗时操作 fmt.Println(\"do something\") time.Sleep(time.Second * 1) b.ResetTimer() for i := 0; i # 显示使用内存信息 go test -bench=\".*\" -benchmem BenchmarkMax-4 323694256 3.678 ns/op 0 B/op 0 allocs/op # 0 B/op 每次执行分配了多少内存 # 0 allocs/op 每次执行分配了多少**次**内存 都是越少越好。 # 指定参与的cpu个数 go test -bench=\".*\" -GOMAXPROCS=2 # 指定测试时间(N)和循环次数(Nx) go test -bench=\".*\" -benchtime=10s 执行10秒 go test -bench=\".*\" -benchtime=100x 执行100次 # 指定测试超时时间 go test -bench=\".*\" -timeout=20s 示例测试 如果你写的模块需要被其他人调用。你可以在代码中写示例测试，用来演示你模块的使用方式。 示例测试一般保存在example_test.go文件中。 函数必须以Example开头，没有输入参数，没有返回值。 示例测试通过输出注释来判断测试是否通过.输出注释格式为 Output: 结果值 或者Unordered output:开头的注释 func ExampleFunc() { fmt.Println(strings.HasPrefix(\"_abc\", \"_\")) fmt.Println(math.Abs(-100)) // Output: // true // 100 } 示例函数命名规则 func Example() { ... } // 代表了整个包的示例 func ExampleF() { ... } // 函数F的示例 func ExampleT() { ... } // 类型T的示例 func ExampleT_M() { ... } // 方法T_M的示例 # 当一个函数 类型 或者方法有多个示例测试时 func ExampleReverse() func ExampleReverse_second() func ExampleReverse_third() 大型示例测试 通常在一个文件中。只用一个Example函数。 TestMain函数 主要用来做测试之前的准备工作和测试之后的清理工作。如连接数据库,清理临时文件等。 函数名必须是TestMain 参数必须是 *testing.M func TestMain(m *testing.M) { fmt.Println(\"do some stepup\") m.Run() fmt.Println(\"do some cleanup\") } Mock测试 在单元测试中,我们经常会碰到如下情况： 函数内部调用了数据库操作等外部依赖。 函数内部包含了一些未实现的调用。 此时,我们可以通过mock来处理。gomock是go官方提供的mock解决方案。 主要分为两部分: gomock库和mockgen gomock包用来完成对象生命周期的管理。 mockgen工具用来生成interface对应的mock类源文件。 安装 # gomock包下载 go get github.com/golang/mock/gomock # mockgen工具下载 go install github.com/golang/mock/mockgen@latest 示例 假设我们现在user中有一个函数是获取用户的微信UUID，但是此方法还没有实现。所以我们没有办法实现这个函数的测试用例。在这种情况下，我们就需要使用mock测试了。 # user.go func GetWechatUUID(wechater wechat.Wechater, name string) string { uuid := wechater.GetUUID(name) return uuid } # interface package wechat type Wechater interface { GetUUID(name string) string } 首先，使用mockgen工具,生成要mock的接口的实现。 mockgen -destination wechat/mock/mock_wechat.go -package mock_wechat fuck_demo/wechat Wechater # -destination: 存放mock类代码的文件。如果你没有设置这个选项，代码将被打印到标准输出 # -package: 用于指定mock类源文件的包名。如果你没有设置这个选项，则包名由mock_和输入文件的包名级联而成 # fuck_demo/wechat 是你接口所在的包 # Wechater 接口名称。可以是多个。用,分隔 使用mock文件,完成单元测试。 可以看到在指定路径下生成了mock_wechat.go文件。其中定义了一些函数和方法。这些方法用来支持我们编写单元测试。 // GetUUID indicates an expected call of GetUUID. func (mr *MockWechaterMockRecorder) GetUUID(arg0 interface{}) *gomock.Call { mr.mock.ctrl.T.Helper() return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetUUID\", reflect.TypeOf((*MockWechater)(nil).GetUUID), arg0) } # 单元测试中使用 func TestGetUUID(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() mockWechater := mock_wechat.NewMockWechater(ctrl) mockWechater.EXPECT().GetUUID(\"dy\").Return(\"dy\") got := GetWechatUUID(mockWechater, \"dy\") if got != \"dy\" { t.Errorf(\"get uuid fail\") } } 通过mock,不用我们自己去实现一个接口。降低了用例编写的复杂度。 mockgen的使用 源码模式 如果有接口文件,则通过源码模式来生成mock代码: mockgen -destination wechat/mock/mock_wechat.go -source wechat/wechat-interface.go # -source 要模拟的接口文件 反射模式 mockgen -destination wechat/mock/mock_wechat.go -package mock_wechat fuck_demo/wechat Wechater # 我们上面的示例用的是这种方式。 注释模式 如果要模拟的接口文件有多个，且分布在不同的文件中。我们需要对每个文件执行多次mockgen命令。mockgen 提供了一种通过注释生成mock文件的方式,需要借助go generate工具 在接口文件代码中,添加以下注释: //go:generate mockgen -destination mock/mock_wechat.go -package wechat fuck_demo/wechat Wechater type Wechater interface { GetUUID(name string) string } # 在命令行中执行 go generate ./... 使用mock代码编写单元测试 # 单元测试中使用 func TestGetUUID(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() mockWechater := mock_wechat.NewMockWechater(ctrl) mockWechater.EXPECT().GetUUID(\"dy\").Return(\"dy\") got := GetWechatUUID(mockWechater, \"dy\") if got != \"dy\" { t.Errorf(\"get uuid fail\") } } 创建mock控制器 defer 操作完之后回收。 使用控制器返回一个mock对象。 mock对象调用 gomock 支持以下参数匹配： gomock.Any()，可以用来表示任意的入参。 gomock.Eq(value)，用来表示与 value 等价的值。 gomock.Not(value)，用来表示非 value 以外的值。 gomock.Nil()，用来表示 None 值。 EXPECT()得到 Mock 的实例，然后调用 Mock 实例的方法，该方法返回第一个Call对象，然后可以对其进行条件约束，比如使用 Mock 实例的 Return 方法约束其返回值。Call对象还提供了以下方法来约束 Mock 实例： func (c *Call) After(preReq *Call) *Call // After声明调用在preReq完成后执行 func (c *Call) AnyTimes() *Call // 允许调用次数为 0 次或更多次 func (c *Call) Do(f interface{}) *Call // 声明在匹配时要运行的操作 func (c *Call) MaxTimes(n int) *Call // 设置最大的调用次数为 n 次 func (c *Call) MinTimes(n int) *Call // 设置最小的调用次数为 n 次 func (c *Call) Return(rets ...interface{}) *Call // // 声明模拟函数调用返回的值 func (c *Call) SetArg(n int, value interface{}) *Call // 声明使用指针设置第 n 个参数的值 func (c *Call) Times(n int) *Call // 设置调用次数为 n 次 fake测试 根据接口伪造一个实现接口的实例。 测试覆盖率 生成测试覆盖率数据 # 当前目录下所有文件全部提取,查看是否有对应的测试用例。生成测试覆盖率数据 go test -coverprofile=coverage.out ./... 分析覆盖率文件 go tool cover -func=coverage.out # 输出 fuck_demo/user/user.go:13: NewUser 100.0% fuck_demo/user/user.go:20: GetName 0.0% fuck_demo/user/user.go:24: SetAge 0.0% fuck_demo/user/user.go:29: PrintHello 0.0% fuck_demo/user/user.go:33: Max 0.0% fuck_demo/user/user.go:37: GetWechatUUID 100.0% total: (statements) 37.5% 生成html文件在浏览器查看 go tool cover -html=coverage.out -o coverage.html [!NOTE] 有时候代码测试覆盖率会作为准许合入分支的一项检查。如果覆盖率不足，会导致合入分支失败。我们可以使用go-junit-report 将覆盖率结构文件转换为xml,供其他CI系统使用。 [!WARNING] 使用mock生成的代码是不需要测试用例的，我们需要将生成的覆盖率文件中mock_*.go的文件去掉，否则会影响整体的测试覆盖率计算。 其他mock sqlmock 模拟数据库连接 httpmock 模拟http请求 bouk/monkey 猴子补丁,替换函数指针来修改任意函数的实现。mock最终解决方案。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/lib/":{"url":"golang/lib/","title":"Go语言三方库","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/lib/aa.html":{"url":"golang/lib/aa.html","title":"Test包","keywords":"","body":"aa aaaa bb aaaa [!NOTE] note...... aaaaaa [!TIP] tip....... aaaaa [!WARNING] warning..... aaaaaa [!DANGER] danger...... ccc aaaaa dddd ddddd bbbbbbbb Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/lib/命令行参数解析工具Pflag.html":{"url":"golang/lib/命令行参数解析工具Pflag.html","title":"命令行参数解析工具-pflag包","keywords":"","body":"概述 pflag是一个更加高级的命令行参数解析工具。pflag是一个完全兼容goflag的包。但其功能更加强大。按照POSIX/ gnu风格的 --flags实现。 在Go项目中，我们经常会在实现各种服务或者命令行工具时使用命令行参数解析来控制应用行为。Pflag包可以为我们提供更加方便的命令行参数解析。 Kubernetes、Helm、Docker、Etcd等项目使用的也是Pflag包来解析命令行参数的。 Pflag包安装 go get github.com/spf13/pflag Pflag包的使用 导入包 import flag \"github.com/spf13/pflag\" pflag.type()方式: 使用长选项的方式将标志解析到指针变量中。 可设置默认值和帮助信息. func main() { var ip *int = pflag.Int(\"flagname\", 123, \"help message for flagname\") pflag.Parse() fmt.Printf(\"%d\\n\", *ip) } ☁ pflagDemo ./main 123 ☁ pflagDemo ./main --flagname 234 234 ☁ pflagDemo ./main -h Usage of ./main: --flagname int help message for flagname (default 123) pflag: help requested pflag.typeVar()方式: 先声名接收变量，使用长选项的方式将falg的值绑定到指定的变量中。 var flagvar int var flagbool bool func main() { pflag.IntVar(&flagvar, \"flagname\", 1234, \"help message\") pflag.BoolVar(&flagbool, \"flagbool\", true, \"flagbool help message\") pflag.Parse() fmt.Printf(\"%v,%v\\n\", flagvar, flagbool) } ☁ pflagDemo ./main 1234,true ☁ pflagDemo ./main --flagbool=false --flagname 2345 2345,false pflag.typeP() 或者 pflag.typeVarP(). 在以上两种方式的基础上,增加命令行段选项支持。 func main() { var ip = pflag.IntP(\"flagname\", \"f\", 1234, \"help message\") var flagBool bool pflag.BoolVarP(&flagBool, \"boolname\", \"b\", true, \"help message\") pflag.Parse() fmt.Printf(\"%d,%v\\n\", *ip, flagBool) } ./main -b=false -f 3333 指定了选项，但是没有指定选项值的默认值 func main() { var ip = pflag.IntP(\"flagname\", \"f\", 1234, \"help message\") pflag.Lookup(\"flagname\").NoOptDefVal = \"4321\" pflag.Parse() fmt.Println(*ip) // ./main 输出 1234 使用默认值 // ./main -f 输出 4321 执行了选项,没有指定值。使用NoOptDefVal的值 // ./main -f=3333 输出 3333 } 命令行语法 --flag // boolean flags, or flags with no option default values --flag x // only on flags without a default value --flag=x # example1: bool类型的flag, 或者设置了 noOptDefVal的flag -f // ok true或者是noOptDefVal的值 -f=true -f=3333 // ok -f true // invalid -f 3333 // invalid //example2: 非bool类型的flag, 或者没有设置noOptDefVal的值 -n 1234 -n=1234 -n1234 都ok flag的\"规范化\" 允许自定义函数.让你的标志名称在代码中使用时更加规范化，且方便用于比较。在命令行中的输入与代码中的标志等价。 例子: func main() { fset := pflag.NewFlagSet(\"test\", pflag.ExitOnError) fset.SetNormalizeFunc(wordSepNormalizeFunc) } // You want -, _, and . in flags to compare the same. aka --my-flag == --my_flag == --my.flag func wordSepNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName { from := []string{\"-\", \"_\"} to := \".\" for _, sep := range from { name = strings.Replace(name, sep, to, -1) } return pflag.NormalizedName(name) } // You want to alias two flags. aka --old-flag-name == --new-flag-name func aliasNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName { switch name { case \"old-flag-name\": name = \"new-flag-name\" } return pflag.NormalizedName(name) } 弃用标志或者标志的简写 func main() { v := pflag.String(\"badflag\", \"hello\", \"help message\") v1 := pflag.IntP(\"flagname\", \"f\", 123, \"help message\") pflag.CommandLine.MarkDeprecated(\"badflag\", \"please use --good-flag instead\") pflag.CommandLine.MarkShorthandDeprecated(\"flagname\", \"please --flagname only\") pflag.Parse() println(*v, *v1) } # 不显示 badflag ./main -h Usage of ./main: --flagname int help message (default 123) # 可以用 badflag 但会出现提示 ./main --badflag world Flag --badflag has been deprecated, please use --good-flag instead # 使用flagname的短选项会有提示 ./main -f 100 Flag shorthand -f has been deprecated, please --flagname only 影藏标志 func main() { var adminAct string pflag.StringVar(&adminAct, \"admin\", \"admin\", \"help message\") pflag.CommandLine.MarkHidden(\"admin\") pflag.Parse() } 使用 help 无法看到admin 标识 pflag包数据结构 每个一个命令行参数都会被解析成一个pflag.Flag类型的变量 type Flag struct { Name string // flag长选项的名称 Shorthand string // flag短选项的名称，一个缩写的字符 Usage string // flag的使用文本 Value Value // flag的值 DefValue string // flag的默认值 Changed bool // 记录flag的值是否有被设置过 NoOptDefVal string // 当flag出现在命令行，但是没有指定选项值时的默认值 Deprecated string // 记录该flag是否被放弃 Hidden bool // 如果值为true，则从help/usage输出信息中隐藏该flag ShorthandDeprecated string // 如果flag的短选项被废弃，当使用flag的短选项时打印该信息 Annotations map[string][]string // 给flag设置注解 } Flag的值是一个Value类型的接口，Value的定义如下: type Value interface { String() string // 将flag类型的值转换为string类型的值，并返回string的内容 Set(string) error // 将string类型的值转换为flag类型的值，转换失败报错 Type() string // 返回flag的类型，例如：string、int、ip等 } Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/lib/配置文件解析工具viper.html":{"url":"golang/lib/配置文件解析工具viper.html","title":"配置文件解析工具-viper包","keywords":"","body":"概述 Vipier 是一个完整的Go应用程序配置文件解析方案。它可以处理任何类型或者格式的配置文件。 源码地址: viper Vipier支持: 设置默认值。 从不同格式的配置文件中读取配置包括json,toml,yaml,hcl,envfile. 从环境变量读取配置 从第三方配置存储服务读取配置 etcd consul并且监听配置改变。 从命令行参数选项中读取配置。 从本地缓冲中读取配置 直接设置值。 Vipie读取配置文件方式的顺序从高到底为: 直接使用 set的方式设置 命令行参数 环境变量 配置文件 kv存储 默认值 [!TIP] viper配置键不区分大小写。 使用 导入包 go get github.com/spf13/viper Viper使用方式。 viper中初始化了一个全局的vipier实例。所以我们可以在导入包后直接使用viper.set等方法设置配置值。我们可以在我们的应用中直接使用这个实例。 var v *Viper func init() { v = New() ...... } 设置默认值 func main() { viper.SetDefault(\"ContentDir\", \"content\") viper.SetDefault(\"LayoutDir\", \"layouts\") fmt.Println(viper.GetString(\"contentdir\")) //ok fmt.Println(viper.GetString(\"ContentDir\")) // ok } 从配置文件读取 func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") viper.AddConfigPath(\".\") viper.AddConfigPath(\"./config\") if err := viper.ReadInConfig(); err != nil { // 如果配置文件未找到的错误想被特殊处理 if _, ok := err.(viper.ConfigFileNotFoundError); ok { fmt.Println(\"config not found\") } else { fmt.Println(\"cofnig file cound but other errors\") panic(err) } } viper.SetDefault(\"app.name\", \"default\") fmt.Println(viper.GetString(\"app.name\")) //配置文件优先级高于默认值 fmt.Println(viper.GetStringSlice(\"app.databases\")) } 回写配置文件 一共有以下几种操作 WriteConfig 按照初始化的配置文件路径 回写配置。如果路径不存在，报错。文件存在则直接覆盖。 SafeWriteConfig 同上 路径不存在，报错。文件存在，不会覆盖。 WriteConfigAs 写入给定的文件路径下。如果文件存在，会覆盖 SafeWriteConfigAs 写入给定的文件路径下。如果文件存在，不会覆盖 不加AS,回写到viper.AddConfigPath(\".\")下的路径下。加AS,指定路径。加Safe,如果文件存在不覆盖。不加Safe，文件存在会覆盖。 //重新设置值 viper.Set(\"app.name\", \"gogogo\") //回写配置文件 viper.WriteConfig() // 回写到AddConfigPath路径中。 viper.SafeWriteConfig() viper.WriteConfigAs(\"./tpl/config.yaml\") viper.SafeWriteConfigAs(\"./tpl/config.yaml\") 配置文件热加载 func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") viper.AddConfigPath(\".\") viper.AddConfigPath(\"./config\") if err := viper.ReadInConfig(); err != nil { // 如果配置文件未找到的错误想被特殊处理 if _, ok := err.(viper.ConfigFileNotFoundError); ok { fmt.Println(\"config not found\") } else { fmt.Println(\"cofnig file cound but other errors\") panic(err) } } viper.WatchConfig() go func() { viper.OnConfigChange(func(e fsnotify.Event) { fmt.Println(e.Name) // Users/duyong/WorkPlace/goDemo/pflagDemo/config.yaml fmt.Println(e.Op) // WRITE fmt.Println(viper.GetString(\"app.name\")) }) }() select {} } 缓存中读取 viper.SetConfigType(\"yaml\") // or viper.SetConfigType(\"YAML\") // any approach to require this configuration into your program. var yamlExample = []byte(` Hacker: true name: steve hobbies: - skateboarding - snowboarding - go clothing: jacket: leather trousers: denim age: 35 eyes : brown beard: true `) viper.ReadConfig(bytes.NewBuffer(yamlExample)) viper.Get(\"name\") // this would be \"steve\" 读取环境变量 提供的方法： AutomaticEnv() BindEnv(string...) : error SetEnvPrefix(string) SetEnvKeyReplacer(string...) *strings.Replacer AllowEmptyEnv(bool) 在处理ENV变量时，重要的是要认识到Viper将ENV变量视为区分大小写的。 Viper提供了一种机制来尝试确保ENV变量是惟一的。通过使用SetEnvPrefix，可以告诉Viper在读取环境变量时使用前缀。BindEnv和AutomaticEnv都将使用这个前缀。 func main() { viper.SetEnvPrefix(\"viper\") // 自动转为大写 // 第一个参数为键名。只有第一个参数时,环境变量默认使用 前缀_大写键名 VIPER_USERNAME viper.BindEnv(\"username\") os.Setenv(\"VIPER_USERNAME\", \"jack\") fmt.Println(viper.Get(\"username\")) // 当有第二个参数时,第二个参数为显示指定的环境变量。就叫ID. viper.BindEnv(\"id\", \"ID\") os.Setenv(\"ID\", \"123\") fmt.Println(viper.Get(\"id\")) } func main() { os.Setenv(\"VIPER_USER_NAME\", \"jack\") os.Setenv(\"VIPER_USER_AGE\", \"20\") viper.AutomaticEnv() viper.SetEnvPrefix(\"VIPER\") // viper.get时 key中的. _ - 被替换为_ viper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\", \"-\", \"_\")) viper.BindEnv(\"user.name\") viper.BindEnv(\"user.age\", \"USER_AGE\") fmt.Println(viper.Get(\"user.name\")) fmt.Println(viper.Get(\"user.age\")) } 与Pflag绑定使用 func main() { // 绑定单个标志 port := pflag.Int(\"port\", 1138, \"Port to run Application server on\") viper.BindPFlag(\"port\", pflag.Lookup(\"port\")) pflag.Parse() fmt.Println(*port) } func main() { // 绑定标志集 port := pflag.Int(\"port\", 1138, \"Port to run Application server on\") viper.BindPFlags(pflag.CommandLine) pflag.Parse() fmt.Println(*port) } 从远程键值对数据库读取 viper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\") viper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" err := viper.ReadRemoteConfig() Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/lib/命令行框架Cobra.html":{"url":"golang/lib/命令行框架Cobra.html","title":"命令行框架Cobra包","keywords":"","body":"概述 Cobra既是一个用于创建强大的现代CLI应用程序的库，也是一个用于生成应用程序和命令文件的程序。 cobra Cobra建立在commands(命令) arguments(参数) 和flags(标志)的结构之上。 好的应用程序被使用时就像在读一个句子。用户可以直观的知道如何使用他。一般有一下两种模式 APPNAME VERB NOUN --ADJECTIVE 或者 APPNAME COMMAND ARG --FLAG APPNAME 应用程序 VERB或者COMMAND 动词。程序要执行的操作。 NOUN或者ARG。 名词。非选项参数。可以代表操作作用的资源。 ADJECTIVE或者FALG。形容词。选项参数。操作资源的修饰符。 如: # server是cmd --port 是flag hugo server --port=1313 # clone是命令，url是选项参数 --bare是非选项参数 git clone URL --bare 安装 命令行安装 go install github.com/spf13/cobra/cobra@latest 安装库 go get -u github.com/spf13/cobra import \"github.com/spf13/cobra\" 目录结构 使用Cobra命令行工具时初始化的项目模板。同样在使用Cobra库时，我们最好也按照此模板来定义我们的目录格式。 ▾ appName/ ▾ cmd/ add.go your.go commands.go here.go main.go package main import ( \"{pathToYourApp}/cmd\" ) func main() { cmd.Execute() } Cobra库的使用 手动实现Cobra命令框架时,我们需要一个main文件和rootcmd文件。你也可以根据自己的需要增加其他命令。 创建rootCmd 我们通常将rootCmd放在cmd/root.go中 var rootCmd = &cobra.Command{ Use: \"hugo\", Short: \"Hugo is a very fast static site generator\", Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // Do Stuff Here }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 我们可以通过viper和pflag(已经集成到cobra中)定义标志和配置绑定。 package cmd import ( \"fmt\" \"os\" homedir \"github.com/mitchellh/go-homedir\" \"github.com/spf13/cobra\" \"github.com/spf13/viper\" ) var rootCmd = &cobra.Command{ Use: \"hugo\", Short: \"Hugo is a very fast static site generator\", Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`, Run: func(cmd *cobra.Command, args []string) { // Do Stuff Here }, } var ( cfgFile string projectBase string userLicense string ) func init() { cobra.OnInitialize(initConfig) rootCmd.PersistentFlags().StringVar(&cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobra.yaml)\") rootCmd.PersistentFlags().StringVarP(&projectBase, \"projectbase\", \"b\", \"\", \"base project directory eg. github.com/spf13/\") rootCmd.PersistentFlags().StringP(\"author\", \"a\", \"YOUR NAME\", \"Author name for copyright attribution\") rootCmd.PersistentFlags().StringVarP(&userLicense, \"license\", \"l\", \"\", \"Name of license for the project (can provide `licensetext` in config)\") rootCmd.PersistentFlags().Bool(\"viper\", true, \"Use Viper for configuration\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\")) viper.BindPFlag(\"projectbase\", rootCmd.PersistentFlags().Lookup(\"projectbase\")) viper.BindPFlag(\"useViper\", rootCmd.PersistentFlags().Lookup(\"viper\")) viper.SetDefault(\"author\", \"NAME HERE \") viper.SetDefault(\"license\", \"apache\") } func initConfig() { // Don't forget to read config either from cfgFile or from home directory! if cfgFile != \"\" { // Use config file from the flag. viper.SetConfigFile(cfgFile) } else { // Find home directory. home, err := homedir.Dir() if err != nil { fmt.Println(err) os.Exit(1) } // Search config in home directory with name \".cobra\" (without extension). viper.AddConfigPath(home) viper.SetConfigName(\".cobra\") } if err := viper.ReadInConfig(); err != nil { fmt.Println(\"Can't read config:\", err) os.Exit(1) } } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 添加命令 可以定义其他命令，并且通常在cmd/目录中给每个命令各自的文件 假设添加一个version命令 // cmd/version.go package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) var versionCmd = &cobra.Command{ Use: \"version\", Short: \"Print the version number of Hugo\", Long: `All software has versions. This is Hugo's`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Hugo Static Site Generator v0.9 -- HEAD\") }, } func init() { rootCmd.AddCommand(versionCmd) } 返回错误 使用RunE回调返回错误 var versionCmd = &cobra.Command{ Use: \"version\", Short: \"Print the version number of Hugo\", Long: `All software has versions. This is Hugo's`, RunE: func(cmd *cobra.Command, args []string) error { if err := someFunc(); err != nil { return err } return nil }, } func init() { rootCmd.AddCommand(versionCmd) } func someFunc() error { return errors.New(\"version cmd is invalid\") } 同Flag一起使用 Falg提供了修饰符来控制命令如何执行。 我们可以为命令分配标志。但是由于标Flag是在不同的位置定义和使用的，所以我们需要在外部定义一个具有正确作用域的变量，以便为标记赋值 持久标志 一个标志可以是'persistent'，这意味着这个标志将对它所分配的命令以及该命令下的每个命令可用。对于全局标志，在根上指定一个标志作为持久标志。 rootCmd.PersistentFlags().BoolVarP(&Verbose, \"verbose\", \"v\", false, \"verbose output\") 本地标志 也可以在本地分配标志，该标志将只应用于该特定的命令。 localCmd.Flags().StringVarP(&Source, \"source\", \"s\", \"\", \"Source directory to read from\") 父命令的本地标志 默认情况下，Cobra只解析目标命令上的本地标志，父命令上的任何本地标志都会被忽略。通过启用命令Command.TraverseChildren。Cobra将在执行目标命令之前解析每个命令的本地标志 command := cobra.Command{ Use: \"print [OPTIONS] [COMMANDS]\", TraverseChildren: true, } 同Vipier一起使用 var author string func init() { rootCmd.PersistentFlags().StringVar(&author, \"author\", \"YOUR NAME\", \"Author name for copyright attribution\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\")) } 在本例中，使用viper绑定持久标志author。注意:当user提供了——author标志时，变量author将不会被设置为config中的值。 标志必选 // 持久标志 rootCmd.PersistentFlags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkPersistentFlagRequired(\"region\") // 本地标志 rootCmd.Flags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkFlagRequired(\"region\") 非选项参数验证 在命令的过程中，经常会传入非选项参数，并且需要对这些非选项参数进行验证，Cobra 提供了机制来对非选项参数进行验证。可以使用 Command 的 Args 字段来验证非选项参数。Cobra 也内置了一些验证函数： NoArgs：如果存在任何非选项参数，该命令将报错。 ArbitraryArgs：该命令将接受任何非选项参数。 OnlyValidArgs：如果有任何非选项参数不在 Command 的 ValidArgs 字段中，该命令将报错。 MinimumNArgs(int)：如果没有至少 N 个非选项参数，该命令将报错。 MaximumNArgs(int)：如果有多于 N 个非选项参数，该命令将报错。 ExactArgs(int)：如果非选项参数个数不为 N，该命令将报错。 ExactValidArgs(int)：如果非选项参数的个数不为 N，或者非选项参数不在 Command 的 ValidArgs 字段中，该命令将报错。 RangeArgs(min, max)：如果非选项参数的个数不在 min 和 max 之间，该命令将报错。 var cmd = &cobra.Command{ Short: \"hello\", Args: func(cmd *cobra.Command, args []string) error { if len(args) 多个顶层命令例子 package main import ( \"fmt\" \"strings\" \"github.com/spf13/cobra\" ) func main() { var echoTimes int var cmdPrint = &cobra.Command{ Use: \"print [string to print]\", Short: \"Print anything to the screen\", Long: `print is for printing anything back to the screen. For many years people have printed back to the screen.`, Args: cobra.MinimumNArgs(1), Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Print: \" + strings.Join(args, \" \")) }, } var cmdEcho = &cobra.Command{ Use: \"echo [string to echo]\", Short: \"Echo anything to the screen\", Long: `echo is for echoing anything back. Echo works a lot like print, except it has a child command.`, Args: cobra.MinimumNArgs(1), Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Echo: \" + strings.Join(args, \" \")) }, } var cmdTimes = &cobra.Command{ Use: \"times [string to echo]\", Short: \"Echo anything to the screen more times\", Long: `echo things multiple times back to the user by providing a count and a string.`, Args: cobra.MinimumNArgs(1), Run: func(cmd *cobra.Command, args []string) { for i := 0; i 帮助选项和版本选项 如果在根命令上设置了version字段，Cobra会添加一个顶级的'——version'标志。使用'——version'标志运行应用程序将使用版本模板将版本打印到标准输出。模板可以通过cmd自定义。SetVersionTemplate(字符串)函数。 命令执行的钩子函数 在运行 Run 函数时，我们可以运行一些钩子函数，比如 PersistentPreRun 和 PreRun 函数在 Run 函数之前执行，PersistentPostRun 和 PostRun 在 Run 函数之后执行。如果子命令没有指定Persistent*Run函数，则子命令将会继承父命令的Persistent*Run函数。这些函数的运行顺序如下： PersistentPreRun PreRun Run PostRun PersistentPostRun package main import ( \"fmt\" \"github.com/spf13/cobra\" ) func main() { var rootCmd = &cobra.Command{ Use: \"root [sub]\", Short: \"My root command\", PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PersistentPreRun with args: %v\\n\", args) }, PreRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PreRun with args: %v\\n\", args) }, Run: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd Run with args: %v\\n\", args) }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PostRun with args: %v\\n\", args) }, PersistentPostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside rootCmd PersistentPostRun with args: %v\\n\", args) }, } var subCmd = &cobra.Command{ Use: \"sub [no options!]\", Short: \"My subcommand\", PreRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd PreRun with args: %v\\n\", args) }, Run: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd Run with args: %v\\n\", args) }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd PostRun with args: %v\\n\", args) }, PersistentPostRun: func(cmd *cobra.Command, args []string) { fmt.Printf(\"Inside subCmd PersistentPostRun with args: %v\\n\", args) }, } rootCmd.AddCommand(subCmd) rootCmd.SetArgs([]string{\"\"}) rootCmd.Execute() fmt.Println() rootCmd.SetArgs([]string{\"sub\", \"arg1\", \"arg2\"}) rootCmd.Execute() } 当“未知命令”发生时的建议 默认开启。如果要关闭执行: command.DisableSuggestions = true // 或者 command.SuggestionsMinimumDistance = 1 为命令生成文档 文档 简单使用 package main import ( \"log\" \"github.com/spf13/cobra\" \"github.com/spf13/cobra/doc\" ) func main() { cmd := &cobra.Command{ Use: \"test\", Short: \"my test program\", } err := doc.GenMarkdownTree(cmd, \"/tmp\") if err != nil { log.Fatal(err) } } 为整个命令树生成文档 package main import ( \"log\" \"io/ioutil\" \"os\" \"k8s.io/kubernetes/pkg/kubectl/cmd\" cmdutil \"k8s.io/kubernetes/pkg/kubectl/cmd/util\" \"github.com/spf13/cobra/doc\" ) func main() { kubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, ioutil.Discard, ioutil.Discard) err := doc.GenMarkdownTree(kubectl, \"./\") if err != nil { log.Fatal(err) } } shell自动补全 文档 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"golang/question/":{"url":"golang/question/","title":"Go经典面试题","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"software/":{"url":"software/","title":"软件安装和使用","keywords":"","body":"Introduction 软件安装和使用篇 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "},"software/GitBook搭建并且关联到GitHub.html":{"url":"software/GitBook搭建并且关联到GitHub.html","title":"GitBook搭建并且关联到GitHub Pages","keywords":"","body":"概览 -- 记录一次使用gitbook写电子书,并且将源码推送到github仓库。最后通过github action自动构建电子书并且发布的过程。 最终效果: 本地编辑文章,生成md文件。push到github仓库，就可以在线通过自定义域名浏览文章。如: 我的笔记本 自动发布书籍的方式 我使用的是第二种方式,这里介绍一下两种方式 1. gitbook在线构建 gitbook 允许你使用md文档的语法，构建出精美的电子书。 gitbook是一个文档或者是电子书托管平台，官方站点就是 gitbook。是一个线上环境。 gitbook也是一个基于node.js的命令行工具。gitbook工具允许我们在本地快速构建书籍结构，下载插件，构建电子书并且支持启动本地web服务来浏览本地的电子书。 这里说一下使用gitbook线上环境自动发布书籍的逻辑: 首先gitbook线上环境允许你在线创建自己的文档,使用md的方式对文档进行编辑。 允许对外发布,分两种方式 1.允许搜索引擎爬取 2.不允许搜索引擎爬取。 对外发布的Space或者是Collection可以绑定自定义的域名,让用户访问。 在线的gitbook仓库也可以和github仓库关联,互相同步。 所以,如果使用gitbook线上环境自动发布书籍,可以这样做: 使用gitbook-cli创建本地书籍 登录gitbook账号,创建Space或者是Collection 创建你的github仓库,用来存储数据源文件。 gitbook仓库与github仓库绑定,授权同步。 这样我们就可以本地写文章,然后推送到github,绑定的仓库有更新时,gitbook会自动从github同步你的源文件。gitbook属于线上环境,会自动构建,安装插件。然后就可以访问了。 这是一种自动发布的方式,但自己的部署的时候碰到一些问题： 网站有时候不能访问，需要fq。 本地构建书籍时,插件可用。推送到线上后,gitbook构建出来的书籍格式很多插件没有被使用。导致书籍体验很不好。例如：目录插件不生效等...。目前还没发现哪里配置的有问题。 所以没有使用这种自动发布的方式,不使用gitbook在线环境，使用的是github的 pages。 2. github pages GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。 静态页面我们依然使用gitbook工具生成。然后按照以下步骤完成书籍自动发布: 安装gitbook工具,本地生成电子书。 安装一些gitbook插件,本地启动服务查看效果。 关联github仓库 创建github pages 使用github action自动构建电子书,并且发布到github pages github pages绑定自定义域名 这种自动发布方式与上面的方式不同点是: 我们相当于是将\"本地\"构建好的完整书籍项目推送到了gh-pages分支。而不是推送源码后在线上构建。 \"本地\"加了引号是因为，当我们使用了github action时, github会提供CI环境为我们进行构建并且将构建好的项目推送到指定分支。所以并不需要你真的每次都在本地构建,然后推送。其实,你每次推送的还是源码文件,剩下的全部都是自动执行。 GitBook命令工具 安装 npm install -g gitbook-cli gitbook -V gitbook ls # 按照提示装好版本 gitook命令使用 gitbook help # 查看帮助 gitbook init [book]。 初始化电子书。会在你指定目录下生成README和SUMMARY gitbook install 安装book.json指定的插件 gitbook build 构建书籍。生成的静态文件在_book中 gitbook serve 启动本地服务,查看电子书 # 还有一些导出书籍命令，可通过帮助文档查看。 书籍构建结构 这里介绍一下构建书籍的目录结构和文件说明 ├── .bookignore # gitbook忽略文件。主要用来指定 gitbook build时不打包到_book的文件 ├── .git ├── .github # github action 工作流目录 ├── .gitignore # 提交到github仓库忽略的文件 ├── README.md # 书籍介绍 ├── SUMMARY.md # 书籍目录 ├── _book # 构建出来的静态文件。此文件夹内就是我们要发布到pages的静态资源 ├── book.json # gitbook配置文件 ├── golang # 自定义的书籍目录 ├── img # 文章图片 ├── node_modules # 插件目录 └── sortware # 自定义的书籍目录 目录文件构建方式 # Summary * [Introduction](README.md) * [Golang](golang/README.md) * [Go语言核心](golang/kernel/README.md) * [Go语言如何测试](golang/kernel/Go语言测试.md) * [Go语言三方库](golang/lib/README.md) * [Test包](golang/lib/aa.md) * [Go经典面试题](golang/question/README.md) * [软件安装和使用](software/README.md) * [GitBook搭建并且关联到GitHub Pages](software/GitBook搭建并且关联到GitHub.md) 每个文件件下要有自己的README文件。 目录文件夹下不能再有目录。不支持书籍嵌套。 插件配置 \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"expandable-chapters-small\", \"code\", \"copy-code-button\", \"-lunr\", \"-search\", \"search-pro\", \"advanced-emoji\", \"github\", \"splitter\", \"page-toc-button\", \"alerts\", \"flexible-alerts\", \"pageview-count\", \"auto-scroll-table\", \"popup\", \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com\" }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy Du Yong \", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 } } 插件可以参考这边文章 GitBook插件整理 github pages配置 官网介绍 关于 GitHub Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。 您可以在 GitHub Pages 示例集合中查看 GitHub Pages 站点的示例。 站点类型: 组织 要发布组织站点，必须创建名为 .github.io 的组织所拥有的仓库 用户 要发布用户站点，必须创建用户帐户所拥有的名为 .github.io 项目 项目站点源文件和项目本身存储在一个仓库中。在不使用自定义域名的情况下,项目站点访问http(s)://.github.io/ 我采用项目站点类型。因为项目站点可以有多个。而个人或者组织站点只能有一个。 新建仓库 gitbook-note 关联本地仓库 git init git remote add origin git@github.com:xiaodulala/gitbook-note.git # 推送到github仓库 注意,要将_book node_modules两个文件夹的内容忽略掉。只提交书籍的源文件。不要提交构建出来的静态资源文件和下载的插件。 git push origin master 构建书籍 # 使用build 构建书籍。默认目录为_book. 注意我们不希望构建出来的静态目录有一些其他的文件。要选择忽略掉。 编写.bookignore 忽略一些文件： .gitignore .github .bookignore #构建 gitbook build 创建远程分支gh-pages分支.并与本地静态资源仓库matser分支关联 cd _book git init git remote add origin git@github.com:xiaodulala/gitbook-note.git git push --force --quiet \"git@github.com:xiaodulala/gitbook-note.git\" master:gh-pages 以上操作后,我们可以在仓库设置中的page页面查看访问地址。 到目前为止,是我们手动构建的。接着要把构建并发布自动化。使用github actions. github actions配置 github actions 是github上用来持续集成和部署的功能。 每次持续继承偶读需要拉取代码、跑测试用例、合并分支、服务部署和发布等操作。github就把这些操作称为actions. github允许开发者把每个操作写成独立的脚本，存放到代码仓库里。供其他人引用。所以，当我们的项目需要使用github actions时，就不需要编写复杂的从0开始的脚本。我们可以直接引用别人写好的actions. github actions 官方市场 gitbook的发布我选用了 这一个插件。 工作流文件如下: name: Build and Publish My GitBook on: workflow_dispatch: push: branches: - master jobs: build: name: Build Gitbook runs-on: ubuntu-latest steps: # Check out the repo first - name: Checkout code uses: actions/checkout@v2 # Run this action to publish gitbook - name: Publish uses: tuliren/publish-gitbook@v1.0.0 with: # specify either github_token or personal_token github_token: ${{ secrets.GITHUB_TOKEN }} # personal_token: ${{ secrets.PERSONAL_TOKEN }} 这样，我们就可以在本地推送源文件后，自动发布了。你可以在github的action选项中查看构建过程和结果。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-23 09:45:26 "}}