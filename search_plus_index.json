{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction welcome Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"操作系统/":{"url":"操作系统/","title":"操作系统","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"数据结构和算法/":{"url":"数据结构和算法/","title":"数据结构和算法","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"编程语言/":{"url":"编程语言/","title":"编程语言","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"数据库/":{"url":"数据库/","title":"数据库","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"云原生/":{"url":"云原生/","title":"云原生","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"区块链/":{"url":"区块链/","title":"区块链","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"工具货架/":{"url":"工具货架/","title":"工具货架","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"三方应用/":{"url":"三方应用/","title":"三方应用","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"安装文档/GitBook搭建并且关联到GitHub.html":{"url":"安装文档/GitBook搭建并且关联到GitHub.html","title":"GitBook搭建并且关联到GitHub Pages","keywords":"","body":"概览 -- 记录一次使用gitbook写电子书,并且将源码推送到github仓库。最后通过github action自动构建电子书并且发布的过程。 最终效果: 本地编辑文章,生成md文件。push到github仓库，就可以在线通过自定义域名浏览文章。如: 我的笔记本 自动发布书籍的方式 我使用的是第二种方式,这里介绍一下两种方式 1. gitbook在线构建 gitbook 允许你使用md文档的语法，构建出精美的电子书。 gitbook是一个文档或者是电子书托管平台，官方站点就是 gitbook。是一个线上环境。 gitbook也是一个基于node.js的命令行工具。gitbook工具允许我们在本地快速构建书籍结构，下载插件，构建电子书并且支持启动本地web服务来浏览本地的电子书。 这里说一下使用gitbook线上环境自动发布书籍的逻辑: 首先gitbook线上环境允许你在线创建自己的文档,使用md的方式对文档进行编辑。 允许对外发布,分两种方式 1.允许搜索引擎爬取 2.不允许搜索引擎爬取。 对外发布的Space或者是Collection可以绑定自定义的域名,让用户访问。 在线的gitbook仓库也可以和github仓库关联,互相同步。 所以,如果使用gitbook线上环境自动发布书籍,可以这样做: 使用gitbook-cli创建本地书籍 登录gitbook账号,创建Space或者是Collection 创建你的github仓库,用来存储数据源文件。 gitbook仓库与github仓库绑定,授权同步。 这样我们就可以本地写文章,然后推送到github,绑定的仓库有更新时,gitbook会自动从github同步你的源文件。gitbook属于线上环境,会自动构建,安装插件。然后就可以访问了。 这是一种自动发布的方式,但自己的部署的时候碰到一些问题： 网站有时候不能访问，需要fq。 本地构建书籍时,插件可用。推送到线上后,gitbook构建出来的书籍格式很多插件没有被使用。导致书籍体验很不好。例如：目录插件不生效等...。目前还没发现哪里配置的有问题。 所以没有使用这种自动发布的方式,不使用gitbook在线环境，使用的是github的 pages。 2. github pages GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。 静态页面我们依然使用gitbook工具生成。然后按照以下步骤完成书籍自动发布: 安装gitbook工具,本地生成电子书。 安装一些gitbook插件,本地启动服务查看效果。 关联github仓库 创建github pages 使用github action自动构建电子书,并且发布到github pages github pages绑定自定义域名 这种自动发布方式与上面的方式不同点是: 我们相当于是将\"本地\"构建好的完整书籍项目推送到了gh-pages分支。而不是推送源码后在线上构建。 \"本地\"加了引号是因为，当我们使用了github action时, github会提供CI环境为我们进行构建并且将构建好的项目推送到指定分支。所以并不需要你真的每次都在本地构建,然后推送。其实,你每次推送的还是源码文件,剩下的全部都是自动执行。 GitBook命令工具 安装 # 先安装nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash # gitbool需要使用10版本 nvm install 10 nvm use 10 # 替换一下镜像源 npm config set registry https://registry.npmmirror.com npm config get registry npm install -g gitbook-cli gitbook -V gitbook ls # 按照提示装好版本 gitook命令使用 gitbook help # 查看帮助 gitbook init [book]。 初始化电子书。会在你指定目录下生成README和SUMMARY gitbook install 安装book.json指定的插件 gitbook build 构建书籍。生成的静态文件在_book中 gitbook serve 启动本地服务,查看电子书 # 还有一些导出书籍命令，可通过帮助文档查看。 书籍构建结构 这里介绍一下构建书籍的目录结构和文件说明 ├── .bookignore # gitbook忽略文件。主要用来指定 gitbook build时不打包到_book的文件 ├── .git ├── .github # github action 工作流目录 ├── .gitignore # 提交到github仓库忽略的文件 ├── README.md # 书籍介绍 ├── SUMMARY.md # 书籍目录 ├── _book # 构建出来的静态文件。此文件夹内就是我们要发布到pages的静态资源 ├── book.json # gitbook配置文件 ├── golang # 自定义的书籍目录 ├── img # 文章图片 ├── node_modules # 插件目录 └── sortware # 自定义的书籍目录 目录文件构建方式 # Summary * [Introduction](README.md) * [Golang](golang/README.md) * [Go语言核心](golang/kernel/README.md) * [Go语言如何测试](golang/kernel/Go语言测试.md) * [Go语言三方库](golang/lib/README.md) * [Test包](golang/lib/aa.md) * [Go经典面试题](golang/question/README.md) * [软件安装和使用](software/README.md) * [GitBook搭建并且关联到GitHub Pages](software/GitBook搭建并且关联到GitHub.md) 每个文件件下要有自己的README文件。 目录文件夹下不能再有目录。不支持书籍嵌套。 插件配置 \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"expandable-chapters-small\", \"code\", \"copy-code-button\", \"-lunr\", \"-search\", \"search-pro\", \"advanced-emoji\", \"github\", \"splitter\", \"page-toc-button\", \"alerts\", \"flexible-alerts\", \"pageview-count\", \"auto-scroll-table\", \"popup\", \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com\" }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy Du Yong \", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 } } 插件可以参考这边文章 GitBook插件整理 github pages配置 官网介绍 关于 GitHub Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。 您可以在 GitHub Pages 示例集合中查看 GitHub Pages 站点的示例。 站点类型: 组织 要发布组织站点，必须创建名为 .github.io 的组织所拥有的仓库 用户 要发布用户站点，必须创建用户帐户所拥有的名为 .github.io 项目 项目站点源文件和项目本身存储在一个仓库中。在不使用自定义域名的情况下,项目站点访问http(s)://.github.io/ 我采用项目站点类型。因为项目站点可以有多个。而个人或者组织站点只能有一个。 新建仓库 gitbook-note 关联本地仓库 git init git remote add origin git@github.com:xiaodulala/gitbook-note.git # 推送到github仓库 注意,要将_book node_modules两个文件夹的内容忽略掉。只提交书籍的源文件。不要提交构建出来的静态资源文件和下载的插件。 git push origin master 构建书籍 # 使用build 构建书籍。默认目录为_book. 注意我们不希望构建出来的静态目录有一些其他的文件。要选择忽略掉。 编写.bookignore 忽略一些文件： .gitignore .github .bookignore #构建 gitbook build 创建远程分支gh-pages分支.并与本地静态资源仓库matser分支关联 cd _book git init git remote add origin git@github.com:xiaodulala/gitbook-note.git git push --force --quiet \"git@github.com:xiaodulala/gitbook-note.git\" master:gh-pages 以上操作后,我们可以在仓库设置中的page页面查看访问地址。 到目前为止,是我们手动构建的。接着要把构建并发布自动化。使用github actions. github actions配置 github actions 是github上用来持续集成和部署的功能。 每次持续继承偶读需要拉取代码、跑测试用例、合并分支、服务部署和发布等操作。github就把这些操作称为actions. github允许开发者把每个操作写成独立的脚本，存放到代码仓库里。供其他人引用。所以，当我们的项目需要使用github actions时，就不需要编写复杂的从0开始的脚本。我们可以直接引用别人写好的actions. github actions 官方市场 gitbook的发布我选用了 这一个插件。 工作流文件如下: name: Build and Publish My GitBook on: workflow_dispatch: push: branches: - master jobs: build: name: Build Gitbook runs-on: ubuntu-latest steps: # Check out the repo first - name: Checkout code uses: actions/checkout@v2 # Run this action to publish gitbook - name: Publish uses: tuliren/publish-gitbook@v1.0.0 with: # specify either github_token or personal_token github_token: ${{ secrets.GITHUB_TOKEN }} # personal_token: ${{ secrets.PERSONAL_TOKEN }} 这样，我们就可以在本地推送源文件后，自动发布了。你可以在github的action选项中查看构建过程和结果。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"安装文档/docker&docker-compose安装.html":{"url":"安装文档/docker&docker-compose安装.html","title":"docker&docker-compose安装","keywords":"","body":"[TOC] docker 安装 根据操作系统安装(需提供外网)官方文档: docker安装 centos # 1.卸载 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2. Enable the nightly or test repositories. sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum-config-manager --enable docker-ce-nightly sudo yum-config-manager --enable docker-ce-test # 3. 查看版本 安装 yum list docker-ce --showduplicates | sort -r sudo yum install docker-ce- docker-ce-cli- containerd.io # sudo yum install docker-ce docker-ce-cli containerd.io 安装最新 # 4. 启动 sudo systemctl start docker sudo systemctl enable docker # 5. 验证 sudo docker run hello-world ubuntu # 1. 卸载 sudo apt-get remove docker docker-engine docker.io containerd runc # 2. Set up the repository sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release # Add Docker’s official GPG key: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # To add the nightly or test repository echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null # 3. 版本列表 安装 sudo apt-get update apt-cache madison docker-ce sudo apt-get install docker-ce= docker-ce-cli= containerd.io # sudo apt-get install docker-ce docker-ce-cli containerd.io 最新版本 # 4. 验证 sudo docker run hello-world Manage Docker as a non-root user # 1. Create the docker group. sudo groupadd docker # 2.Add your user to the docker group. sudo usermod -aG docker $USER # 3. Log out and log back in so that your group membership is re-evaluated. newgrp docker Configure Docker to start on boot sudo systemctl enable docker.service sudo systemctl enable containerd.service 加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json docker-compose 安装 二进制下载 脚本安装 sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 卸载 sudo yum remove docker-ce docker-ce-cli containerd.io sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 问题 centos 3.10.0-229.7.2.el7.x86_64 这个版本 只要安装最新的docker,端口映射无法访问。 安装旧版本 sudo yum -y --downloadonly update sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sudo yum -y install docker-ce-18.03.1.ce # 剩下都一样 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"安装文档/docker-compose安装软件.html":{"url":"安装文档/docker-compose安装软件.html","title":"docker-compose启动应用","keywords":"","body":"Mysql 创建目录 # 创建目录 mkdir -p mysql/datadir mysql/conf mysql/mydir Mysql配置文件 vim ./mysql/conf/my.cnf [mysqld] user=mysql default-storage-engine=INNODB #character-set-server=utf8 character-set-client-handshake=FALSE character-set-server=utf8mb4 collation-server=utf8mb4_unicode_ci init_connect='SET NAMES utf8mb4' # 主从时使用 server_id=1 # 开启binlog 按需开启。影响性能 log-bin=mysql-bin # 行模式(5.7默认) binlog_format=row # binlog同步事务数(5.7默认) sync_binlog=1 skip-grant-tables [client] #utf8mb4字符集可以存储emoji表情字符 #default-character-set=utf8 default-character-set=utf8mb4 [mysql] #default-character-set=utf8 default-character-set=utf8mb4 docker-compose.yaml version: '3' services: dy_mysql: restart: always image: mysql:5.7 container_name: dy_mysql volumes: - ./mydir:/mydir - ./datadir:/var/lib/mysql - ./conf/my.cnf:/etc/my.cnf environment: - MYSQL_ROOT_PASSWORD=duyong - TZ=Asia/Shanghai ports: - 3306:3306 修改密码 # 进入容器 docker exec -it dy_mysql bash # 进入mysql mysql # 修改密码 mysql>update mysql.user set authentication_string=password('duyong') where user='root'; # 允许root远程连接(看需要设置) grant all privileges on *.* to 'root'@'%' identified by 'duyong' with grant option; flush privileges; # 退出容器 删除配置中的skip-grant-tables 重启容器 Postgres + pgadmin4 创建目录 mkdir -p postgres/data docker-compose.yaml version: '3.1' services: postgres: container_name: duyong_postgres image: postgres:12.9 restart: always environment: POSTGRES_USER: root POSTGRES_PASSWORD: root POSTGRES_DB: duyong ports: - 5432:5432 volumes: - ./data:/var/lib/postgresql/data pgadmin4: container_name: duyong_pgadmin4 image: dpage/pgadmin4 restart: always environment: PGADMIN_DEFAULT_EMAIL: admin@fskj.com PGADMIN_DEFAULT_PASSWORD: 123 ports: - 18080:80 zookeeper单机集群 创建目录 mkdir -p zk docker-compose.yaml version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 查看集群状态 # 进入容器 docker exec -it zk-single_zoo1_1 bash # ./bin/zkServer.sh status Using config: /conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: follower zookeeper多机集群 机器 节点 ip zk node1 10.0.0.99 zk1 node2 10.0.0.100 zk2 node3 10.0.0.101 zk3 分别创建目录 # 99 mkdir -p zk1 #100 mkdir -p zk2 #101 mkdir -p zk3 docker-compose.yaml # 10.0.0.99 version: '3.1' services: zoo: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=10.0.0.100:2888:3888;2181 server.3=10.0.0.101:2888:3888;2181 # 10.0.0.100 version: '3.1' services: zoo: image: zookeeper restart: always hostname: zoo2 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=10.0.0.99:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=10.0.0.101:2888:3888;2181 # 10.0.0.101 version: '3.1' services: zoo: image: zookeeper restart: always hostname: zoo3 ports: - 2181:2181 - 2888:2888 - 3888:3888 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=10.0.0.99:2888:3888;2181 server.2=10.0.0.100:2888:3888;2181 server.3=zoo3:2888:3888;2181 ZK+Kafka单机集群 创建资源目录 mkdir -p kafka-single docker-compose.yaml version: '3.1' services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 kafka1: image: wurstmeister/kafka restart: always hostname: kafka1 container_name: kafka1 ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka1 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2182,zoo3:2183 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka1:9092 KAFKA_LISTENERS: PLAINTEXT://kafka1:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 volumes: - ./kafka1/logs:/kafka kafka2: image: wurstmeister/kafka restart: always hostname: kafka2 container_name: kafka2 ports: - 9093:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2182,zoo3:2183 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka2:9092 KAFKA_LISTENERS: PLAINTEXT://kafka2:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 volumes: - ./kafka2/logs:/kafka kafka3: image: wurstmeister/kafka restart: always hostname: kafka3 container_name: kafka3 ports: - 9094:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka3 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2182,zoo3:2183 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka3:9092 KAFKA_LISTENERS: PLAINTEXT://kafka3:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 volumes: - ./kafka3/logs:/kafka 测试集群 # 生产者 docker exec -it kafka1 bash # 创建topic kafka-topics.sh --create --zookeeper 10.0.0.99:2181 --replication-factor 1 --partitions 1 --topic test1 # 容器1发送消息 kafka-console-producer.sh --broker-list 10.0.0.99:9092 --topic test1 # 进入kakfa2容器查看消息 docker exec -it kafka2 bash kafka-console-consumer.sh --bootstrap-server 10.0.0.99:9092 --topic test1 --from-beginning Kafka多机集群 和多机zk配合使用 # 10.0.0.99 version: '3.1' services: kafka1: image: wurstmeister/kafka restart: always hostname: kafka1 container_name: kafka1 ports: - 9092:9092 environment: KAFKA_BROKER_ID: 1 KAFKA_ADVERTISED_HOST_NAME: 10.0.0.99 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: 10.0.0.99:2181,10.0.0.100:2181,10.0.0.101:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://10.0.0.99:9092 KAFKA_LISTENERS: PLAINTEXT://kafka1:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 volumes: - ./logs:/kafka # 10.0.0.100 version: '3.1' services: kafka2: image: wurstmeister/kafka restart: always hostname: kafka2 container_name: kafka2 ports: - 9092:9092 environment: KAFKA_BROKER_ID: 2 KAFKA_ADVERTISED_HOST_NAME: 10.0.0.100 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: 10.0.0.99:2181,10.0.0.100:2181,10.0.0.101:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://10.0.0.100:9092 KAFKA_LISTENERS: PLAINTEXT://kafka2:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 volumes: - ./logs:/kafka # 10.0.0.101 version: '3.1' services: kafka3: image: wurstmeister/kafka restart: always hostname: kafka3 container_name: kafka3 ports: - 9092:9092 environment: KAFKA_BROKER_ID: 3 KAFKA_ADVERTISED_HOST_NAME: 10.0.0.101 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: 10.0.0.99:2181,10.0.0.100:2181,10.0.0.101:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://10.0.0.101:9092 KAFKA_LISTENERS: PLAINTEXT://kafka3:9092 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 volumes: - ./logs:/kafka NSQ 单机部署 version: '3' services: nsqlookupd_0: image: nsqio/nsq command: /nsqlookupd --broadcast-address=10.3.1.127 --tcp-address=:14160 --http-address=:14161 restart: always ports: - \"14160:14160\" - \"14161:14161\" nsqlookupd_1: image: nsqio/nsq command: /nsqlookupd --broadcast-address=10.3.1.127 --tcp-address=:14170 --http-address=:14171 restart: always ports: - \"14170:14170\" - \"14171:14171\" nsqd_0: image: nsqio/nsq command: /nsqd --broadcast-address=10.3.1.127 --tcp-address=:14150 --http-address=:14151 --lookupd-tcp-address=10.3.1.127:14160 --lookupd-tcp-address=10.3.1.127:14170 depends_on: - nsqlookupd_0 - nsqlookupd_1 ports: - \"14150:14150\" - \"14151:14151\" restart: always volumes: - /home/duyong/dy_work/docker_data/nsq_simple/0_nsqd_data:/data nsqd_1: image: nsqio/nsq command: /nsqd --broadcast-address=10.3.1.127 --tcp-address=:14140 --http-address=:14141 --lookupd-tcp-address=10.3.1.127:14160 --lookupd-tcp-address=10.3.1.127:14170 depends_on: - nsqlookupd_0 - nsqlookupd_1 ports: - \"14140:14140\" - \"14141:14141\" restart: always volumes: - /home/duyong/dy_work/docker_data/nsq_simple/1_nsqd_data:/data nsqd_2: image: nsqio/nsq command: /nsqd --broadcast-address=10.3.1.127 --tcp-address=:14130 --http-address=:14131 --lookupd-tcp-address=10.3.1.127:14160 --lookupd-tcp-address=10.3.1.127:14170 depends_on: - nsqlookupd_0 - nsqlookupd_1 ports: - \"14130:14130\" - \"14131:14131\" restart: always volumes: - /home/duyong/dy_work/docker_data/nsq_simple/2_nsqd_data:/data nsqadmin: image: nsqio/nsq command: /nsqadmin --lookupd-http-address=nsqlookupd:14161 --lookupd-http-address=nsqlookupd:14171 depends_on: - nsqlookupd_0 - nsqlookupd_1 ports: - \"4171:4171\" restart: always Redis version: '3' services: redis: image: redis:latest container_name: duyong_redis volumes: - ./data:/data - ./redis.conf:/usr/local/etc/redis/redis.conf - ./logs:/logs ports: - 6379:6379 restart: always Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "},"安装文档/dapr单机离线安装.html":{"url":"安装文档/dapr单机离线安装.html","title":"dapr离线安装","keywords":"","body":"[TOC] Dapr Cli 官方在线安装方式 官方安装文档: https://docs.dapr.io/getting-started/install-dapr-cli 安装命令: wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | DAPR_INSTALL_DIR=\"$HOME/dapr\" /bin/bash 通过指定上面的命令,我们知道需要下载一个安装脚本，并执行脚本。但是在这个过程中，都有可能遇到网络受限问题。 duyong@duyong-ubuntu:~/dev-tools/dapr$ wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | DAPR_INSTALL_DIR=\"$HOME/dapr\" /bin/bash Getting the latest Dapr CLI... Your system is linux_amd64 Installing Dapr CLI... Installing v1.8.0 Dapr CLI... Downloading https://github.com/dapr/cli/releases/download/v1.8.0/dapr_linux_amd64.tar.gz ... Dapr 离线安装 文档： https://docs.dapr.io/operations/hosting/self-hosted/self-hosted-airgap/ 下载安装包 此安装包包含 DaprCli Dapr 用这种离线方式安装，不需要在单独安葬daprCli 下载地址 https://github.com/dapr/installer-bundle/releases 根据系统选择版本 解压安装包 tar xzvf daprbundle_linux_amd64.tar.gz 将dapr cli 移动到目录 cd daprbundle/ sudo cp dapr /usr/local/bin/ 通过dapr cli 启动dapr # 我自己指定了网络，可以不指定 dapr init --from-dir . # 输出结果 ⌛ Making the jump to hyperspace... ⚠ Local bundle installation using --from-dir flag is currently a preview feature and is subject to change. It is only available from CLI version 1.7 onwards. ℹ️ Installing runtime version 1.8.0 ↑ Extracting binaries and setting up components... Loaded image: daprio/dapr:1.8.0 ↑ Extracting binaries and setting up components... Dapr runtime installed to /home/duyong/.dapr/bin, you may run the following to add it to your path if you want to run daprd directly: export PATH=$PATH:/home/duyong/.dapr/bin ✅ Extracting binaries and setting up components... ✅ Extracted binaries and completed components set up. ℹ️ daprd binary has been installed to /home/duyong/.dapr/bin. ℹ️ dapr_placement_mb container is running. ℹ️ Use `docker ps` to check running containers. ✅ Success! Dapr is up and running. To get started, go here: https://aka.ms/dapr-getting-started 这里只启动了dapr_placement 容器,自己启动redis和zipkin docker run --name \"dapr_zipkin\" --restart always -d -p 9411:9411 openzipkin/zipkin docker run --name \"dapr_redis\" --restart always -d -p 6379:6379 redislabs/rejson Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 06:54:51 "}}