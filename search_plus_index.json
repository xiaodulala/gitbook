{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction welcome Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"golang/":{"url":"golang/","title":"Golang","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"golang/kernel/":{"url":"golang/kernel/","title":"Go语言核心","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"golang/kernel/Go语言测试.html":{"url":"golang/kernel/Go语言测试.html","title":"Go语言如何测试","keywords":"","body":" 概述 在Go项目开发中,我们需要保证我们开发的模块功能稳定，且性能高效。所以我们要对我们自己的模块进行单元测试和性能测试。 在Go语言中，提供了Testing包来对我们的代码进行测试。 测试用例规范 测试用例文件必须以_test.go结尾。go test命令执行时会遍历当前包下所有的以_test.go文件作为测试用例源码文件。 测试用例函数必须以 Test、Benchmark、Example开头,后面直接跟函数名，函数名首字母需要大写。如：TestPrintHello。如果一个函数有多个测试用例,函数名称尽量表达出此函数的测试目的。 测试用例中变量命名规范: 测试用例中我们经常会定义输入和输出变量,最后比较输入和输出来判断测试用例是否通过。这两类变量通常定义为 expencted/actual或者是got/want。 单元测试 单元测试都是以Test开头。函数参数必须为 *test.T 如: func TestPrintHello(t *testing.T) { want := \"dy\" if got := PrintHello(\"dy\"); got != want { t.Errorf(\"want %s,bug got %s\", want, got) } } 这样的写法需要每次使用if比较输入和输出。我们可以使用github.com/stretchr/testify包来直接对比输入和输出。 func TestPrintHello(t *testing.T) { want := \"dy\" got := PrintHello(\"dy\") assert.Equal(t, want, got, \"values should be equal\") } 执行go test需要指定包路径,否则默认执行当前路径下的包的测试用例 # 以上测试用例执行 go test ./user go test -v参数,显示所有测试函数的运行细节。 go test -v ./user go test -run= 指定要指定的测试函数 go test -run=\"TestPrint.*\" go test -count=N 指定函数执行次数 go test -v -run=\"TestPrint.*\" -count=2 ./user 多输入测试用例 如果测试用例中要枚举多个输入进行测试。最好的方式是定义一个输出输出结构,遍历执行并对比结果: func TestPrintHelloMutil(t *testing.T) { tests := []struct { arg string want string }{ {arg: \"dy\", want: \"dy\"}, {arg: \"abc\", want: \"abc\"}, } for _, tt := range tests { got := PrintHello(tt.arg) assert.Equal(t, tt.want, got, \"values should be equal\") } } 自动生成单元测试代码 通过上面的示例我们大概了解,大部分的测试用例基本套路就是定义参数得到got。和之前的want做比较。这样就可以抽象出一个模型。 为了减少编写测试用例的时间,我们可以使用 gotests库来自动生成测试用例代码。这个库就是上面模型的实现。 安装工具 # go 生成测试用例代码 cd /users gotests -all -w . 补全代码 func TestNewUser(t *testing.T) { type args struct { name string age uint8 } tests := []struct { name string args args want *User wantErr bool }{ // TODO: Add test cases. {name: \"with all\", args: args{name: \"dy\", age: 20}, want: &User{Name: \"dy\", Age: 20}, wantErr: false}, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { got, err := NewUser(tt.args.name, tt.args.age) if (err != nil) != tt.wantErr { t.Errorf(\"NewUser() error = %v, wantErr %v\", err, tt.wantErr) return } if !reflect.DeepEqual(got, tt.want) { t.Errorf(\"NewUser() = %v, want %v\", got, tt.want) } }) } } 补全: // TODO: Add test cases. 性能测试 函数名称必须以Benchmark开头 参数必须是 Testing.B # b.N 为循环次数。N会在运行时自动调整。知道性能测试可以持续运行足够的时间。 func BenchmarkMax(b *testing.B) { for i := 0; i 运行性能测试函数 go test -bench=\".*\" ` # 输出 goos: darwin goarch: amd64 pkg: fuck_demo/user cpu: Intel(R) Core(TM) i5-5287U CPU @ 2.90GHz BenchmarkMax-4 315559854 3.681 ns/op PASS ok fuck_demo/user 2.086s # BenchmarkMax-4 4个cpu线程参与了此次测试。 # 315559854 循环了多少次。 # 3.681 ns/op 每次操作耗时 3.681纳秒。 需要注意,如果在性能测试函数中有一些耗时的初始化操作，这个时间不能计算在性能测试之内。所以需要重置性能计数。 func BenchmarkMax(b *testing.B) { // 耗时操作 fmt.Println(\"do something\") time.Sleep(time.Second * 1) b.ResetTimer() for i := 0; i # 显示使用内存信息 go test -bench=\".*\" -benchmem BenchmarkMax-4 323694256 3.678 ns/op 0 B/op 0 allocs/op # 0 B/op 每次执行分配了多少内存 # 0 allocs/op 每次执行分配了多少**次**内存 都是越少越好。 # 指定参与的cpu个数 go test -bench=\".*\" -GOMAXPROCS=2 # 指定测试时间(N)和循环次数(Nx) go test -bench=\".*\" -benchtime=10s 执行10秒 go test -bench=\".*\" -benchtime=100x 执行100次 # 指定测试超时时间 go test -bench=\".*\" -timeout=20s 示例测试 如果你写的模块需要被其他人调用。你可以在代码中写示例测试，用来演示你模块的使用方式。 示例测试一般保存在example_test.go文件中。 函数必须以Example开头，没有输入参数，没有返回值。 示例测试通过输出注释来判断测试是否通过.输出注释格式为 Output: 结果值 或者Unordered output:开头的注释 func ExampleFunc() { fmt.Println(strings.HasPrefix(\"_abc\", \"_\")) fmt.Println(math.Abs(-100)) // Output: // true // 100 } 示例函数命名规则 func Example() { ... } // 代表了整个包的示例 func ExampleF() { ... } // 函数F的示例 func ExampleT() { ... } // 类型T的示例 func ExampleT_M() { ... } // 方法T_M的示例 # 当一个函数 类型 或者方法有多个示例测试时 func ExampleReverse() func ExampleReverse_second() func ExampleReverse_third() 大型示例测试 通常在一个文件中。只用一个Example函数。 TestMain函数 主要用来做测试之前的准备工作和测试之后的清理工作。如连接数据库,清理临时文件等。 函数名必须是TestMain 参数必须是 *testing.M func TestMain(m *testing.M) { fmt.Println(\"do some stepup\") m.Run() fmt.Println(\"do some cleanup\") } Mock测试 在单元测试中,我们经常会碰到如下情况： 函数内部调用了数据库操作等外部依赖。 函数内部包含了一些未实现的调用。 此时,我们可以通过mock来处理。gomock是go官方提供的mock解决方案。 主要分为两部分: gomock库和mockgen gomock包用来完成对象生命周期的管理。 mockgen工具用来生成interface对应的mock类源文件。 安装 # gomock包下载 go get github.com/golang/mock/gomock # mockgen工具下载 go install github.com/golang/mock/mockgen@latest 示例 假设我们现在user中有一个函数是获取用户的微信UUID，但是此方法还没有实现。所以我们没有办法实现这个函数的测试用例。在这种情况下，我们就需要使用mock测试了。 # user.go func GetWechatUUID(wechater wechat.Wechater, name string) string { uuid := wechater.GetUUID(name) return uuid } # interface package wechat type Wechater interface { GetUUID(name string) string } 首先，使用mockgen工具,生成要mock的接口的实现。 mockgen -destination wechat/mock/mock_wechat.go -package mock_wechat fuck_demo/wechat Wechater # -destination: 存放mock类代码的文件。如果你没有设置这个选项，代码将被打印到标准输出 # -package: 用于指定mock类源文件的包名。如果你没有设置这个选项，则包名由mock_和输入文件的包名级联而成 # fuck_demo/wechat 是你接口所在的包 # Wechater 接口名称。可以是多个。用,分隔 使用mock文件,完成单元测试。 可以看到在指定路径下生成了mock_wechat.go文件。其中定义了一些函数和方法。这些方法用来支持我们编写单元测试。 // GetUUID indicates an expected call of GetUUID. func (mr *MockWechaterMockRecorder) GetUUID(arg0 interface{}) *gomock.Call { mr.mock.ctrl.T.Helper() return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetUUID\", reflect.TypeOf((*MockWechater)(nil).GetUUID), arg0) } # 单元测试中使用 func TestGetUUID(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() mockWechater := mock_wechat.NewMockWechater(ctrl) mockWechater.EXPECT().GetUUID(\"dy\").Return(\"dy\") got := GetWechatUUID(mockWechater, \"dy\") if got != \"dy\" { t.Errorf(\"get uuid fail\") } } 通过mock,不用我们自己去实现一个接口。降低了用例编写的复杂度。 mockgen的使用 源码模式 如果有接口文件,则通过源码模式来生成mock代码: mockgen -destination wechat/mock/mock_wechat.go -source wechat/wechat-interface.go # -source 要模拟的接口文件 反射模式 mockgen -destination wechat/mock/mock_wechat.go -package mock_wechat fuck_demo/wechat Wechater # 我们上面的示例用的是这种方式。 注释模式 如果要模拟的接口文件有多个，且分布在不同的文件中。我们需要对每个文件执行多次mockgen命令。mockgen 提供了一种通过注释生成mock文件的方式,需要借助go generate工具 在接口文件代码中,添加以下注释: //go:generate mockgen -destination mock/mock_wechat.go -package wechat fuck_demo/wechat Wechater type Wechater interface { GetUUID(name string) string } # 在命令行中执行 go generate ./... 使用mock代码编写单元测试 # 单元测试中使用 func TestGetUUID(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() mockWechater := mock_wechat.NewMockWechater(ctrl) mockWechater.EXPECT().GetUUID(\"dy\").Return(\"dy\") got := GetWechatUUID(mockWechater, \"dy\") if got != \"dy\" { t.Errorf(\"get uuid fail\") } } 创建mock控制器 defer 操作完之后回收。 使用控制器返回一个mock对象。 mock对象调用 gomock 支持以下参数匹配： gomock.Any()，可以用来表示任意的入参。 gomock.Eq(value)，用来表示与 value 等价的值。 gomock.Not(value)，用来表示非 value 以外的值。 gomock.Nil()，用来表示 None 值。 EXPECT()得到 Mock 的实例，然后调用 Mock 实例的方法，该方法返回第一个Call对象，然后可以对其进行条件约束，比如使用 Mock 实例的 Return 方法约束其返回值。Call对象还提供了以下方法来约束 Mock 实例： func (c *Call) After(preReq *Call) *Call // After声明调用在preReq完成后执行 func (c *Call) AnyTimes() *Call // 允许调用次数为 0 次或更多次 func (c *Call) Do(f interface{}) *Call // 声明在匹配时要运行的操作 func (c *Call) MaxTimes(n int) *Call // 设置最大的调用次数为 n 次 func (c *Call) MinTimes(n int) *Call // 设置最小的调用次数为 n 次 func (c *Call) Return(rets ...interface{}) *Call // // 声明模拟函数调用返回的值 func (c *Call) SetArg(n int, value interface{}) *Call // 声明使用指针设置第 n 个参数的值 func (c *Call) Times(n int) *Call // 设置调用次数为 n 次 fake测试 根据接口伪造一个实现接口的实例。 测试覆盖率 生成测试覆盖率数据 # 当前目录下所有文件全部提取,查看是否有对应的测试用例。生成测试覆盖率数据 go test -coverprofile=coverage.out ./... 分析覆盖率文件 go tool cover -func=coverage.out # 输出 fuck_demo/user/user.go:13: NewUser 100.0% fuck_demo/user/user.go:20: GetName 0.0% fuck_demo/user/user.go:24: SetAge 0.0% fuck_demo/user/user.go:29: PrintHello 0.0% fuck_demo/user/user.go:33: Max 0.0% fuck_demo/user/user.go:37: GetWechatUUID 100.0% total: (statements) 37.5% 生成html文件在浏览器查看 go tool cover -html=coverage.out -o coverage.html [!NOTE] 有时候代码测试覆盖率会作为准许合入分支的一项检查。如果覆盖率不足，会导致合入分支失败。我们可以使用go-junit-report 将覆盖率结构文件转换为xml,供其他CI系统使用。 [!WARNING] 使用mock生成的代码是不需要测试用例的，我们需要将生成的覆盖率文件中mock_*.go的文件去掉，否则会影响整体的测试覆盖率计算。 其他mock sqlmock 模拟数据库连接 httpmock 模拟http请求 bouk/monkey 猴子补丁,替换函数指针来修改任意函数的实现。mock最终解决方案。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"golang/lib/":{"url":"golang/lib/","title":"Go语言三方库","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"golang/lib/aa.html":{"url":"golang/lib/aa.html","title":"Test包","keywords":"","body":"aa aaaa bb aaaa [!NOTE] note...... aaaaaa [!TIP] tip....... aaaaa [!WARNING] warning..... aaaaaa [!DANGER] danger...... ccc aaaaa dddd ddddd bbbbbbbb Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"golang/question/":{"url":"golang/question/","title":"Go经典面试题","keywords":"","body":"Introduction Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"software/":{"url":"software/","title":"软件安装和使用","keywords":"","body":"Introduction 软件安装和使用篇 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "},"software/GitBook搭建并且关联到GitHub.html":{"url":"software/GitBook搭建并且关联到GitHub.html","title":"GitBook搭建并且关联到GitHub Pages","keywords":"","body":"概览 -- 记录一次使用gitbook写电子书,并且将源码推送到github仓库。最后通过github action自动构建电子书并且发布的过程。 最终效果: 本地编辑文章,生成md文件。push到github仓库，就可以在线通过自定义域名浏览文章。如: 我的笔记本 自动发布书籍的方式 我使用的是第二种方式,这里介绍一下两种方式 1. gitbook在线构建 gitbook 允许你使用md文档的语法，构建出精美的电子书。 gitbook是一个文档或者是电子书托管平台，官方站点就是 gitbook。是一个线上环境。 gitbook也是一个基于node.js的命令行工具。gitbook工具允许我们在本地快速构建书籍结构，下载插件，构建电子书并且支持启动本地web服务来浏览本地的电子书。 这里说一下使用gitbook线上环境自动发布书籍的逻辑: 首先gitbook线上环境允许你在线创建自己的文档,使用md的方式对文档进行编辑。 允许对外发布,分两种方式 1.允许搜索引擎爬取 2.不允许搜索引擎爬取。 对外发布的Space或者是Collection可以绑定自定义的域名,让用户访问。 在线的gitbook仓库也可以和github仓库关联,互相同步。 所以,如果使用gitbook线上环境自动发布书籍,可以这样做: 使用gitbook-cli创建本地书籍 登录gitbook账号,创建Space或者是Collection 创建你的github仓库,用来存储数据源文件。 gitbook仓库与github仓库绑定,授权同步。 这样我们就可以本地写文章,然后推送到github,绑定的仓库有更新时,gitbook会自动从github同步你的源文件。gitbook属于线上环境,会自动构建,安装插件。然后就可以访问了。 这是一种自动发布的方式,但自己的部署的时候碰到一些问题： 网站有时候不能访问，需要fq。 本地构建书籍时,插件可用。推送到线上后,gitbook构建出来的书籍格式很多插件没有被使用。导致书籍体验很不好。例如：目录插件不生效等...。目前还没发现哪里配置的有问题。 所以没有使用这种自动发布的方式,不使用gitbook在线环境，使用的是github的 pages。 2. github pages GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。 静态页面我们依然使用gitbook工具生成。然后按照以下步骤完成书籍自动发布: 安装gitbook工具,本地生成电子书。 安装一些gitbook插件,本地启动服务查看效果。 关联github仓库 创建github pages 使用github action自动构建电子书,并且发布到github pages github pages绑定自定义域名 这种自动发布方式与上面的方式不同点是: 我们相当于是将\"本地\"构建好的完整书籍项目推送到了gh-pages分支。而不是推送源码后在线上构建。 \"本地\"加了引号是因为，当我们使用了github action时, github会提供CI环境为我们进行构建并且将构建好的项目推送到指定分支。所以并不需要你真的每次都在本地构建,然后推送。其实,你每次推送的还是源码文件,剩下的全部都是自动执行。 GitBook命令工具 安装 npm install -g gitbook-cli gitbook -V gitbook ls # 按照提示装好版本 gitook命令使用 gitbook help # 查看帮助 gitbook init [book]。 初始化电子书。会在你指定目录下生成README和SUMMARY gitbook install 安装book.json指定的插件 gitbook build 构建书籍。生成的静态文件在_book中 gitbook serve 启动本地服务,查看电子书 # 还有一些导出书籍命令，可通过帮助文档查看。 书籍构建结构 这里介绍一下构建书籍的目录结构和文件说明 ├── .bookignore # gitbook忽略文件。主要用来指定 gitbook build时不打包到_book的文件 ├── .git ├── .github # github action 工作流目录 ├── .gitignore # 提交到github仓库忽略的文件 ├── README.md # 书籍介绍 ├── SUMMARY.md # 书籍目录 ├── _book # 构建出来的静态文件。此文件夹内就是我们要发布到pages的静态资源 ├── book.json # gitbook配置文件 ├── golang # 自定义的书籍目录 ├── img # 文章图片 ├── node_modules # 插件目录 └── sortware # 自定义的书籍目录 目录文件构建方式 # Summary * [Introduction](README.md) * [Golang](golang/README.md) * [Go语言核心](golang/kernel/README.md) * [Go语言如何测试](golang/kernel/Go语言测试.md) * [Go语言三方库](golang/lib/README.md) * [Test包](golang/lib/aa.md) * [Go经典面试题](golang/question/README.md) * [软件安装和使用](software/README.md) * [GitBook搭建并且关联到GitHub Pages](software/GitBook搭建并且关联到GitHub.md) 每个文件件下要有自己的README文件。 目录文件夹下不能再有目录。不支持书籍嵌套。 插件配置 \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"expandable-chapters-small\", \"code\", \"copy-code-button\", \"-lunr\", \"-search\", \"search-pro\", \"advanced-emoji\", \"github\", \"splitter\", \"page-toc-button\", \"alerts\", \"flexible-alerts\", \"pageview-count\", \"auto-scroll-table\", \"popup\", \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com\" }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy Du Yong \", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 } } 插件可以参考这边文章 GitBook插件整理 github pages配置 官网介绍 关于 GitHub Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。 您可以在 GitHub Pages 示例集合中查看 GitHub Pages 站点的示例。 站点类型: 组织 要发布组织站点，必须创建名为 .github.io 的组织所拥有的仓库 用户 要发布用户站点，必须创建用户帐户所拥有的名为 .github.io 项目 项目站点源文件和项目本身存储在一个仓库中。在不使用自定义域名的情况下,项目站点访问http(s)://.github.io/ 我采用项目站点类型。因为项目站点可以有多个。而个人或者组织站点只能有一个。 新建仓库 gitbook-note 关联本地仓库 git init git remote add origin git@github.com:xiaodulala/gitbook-note.git # 推送到github仓库 注意,要将_book node_modules两个文件夹的内容忽略掉。只提交书籍的源文件。不要提交构建出来的静态资源文件和下载的插件。 git push origin master 构建书籍 # 使用build 构建书籍。默认目录为_book. 注意我们不希望构建出来的静态目录有一些其他的文件。要选择忽略掉。 编写.bookignore 忽略一些文件： .gitignore .github .bookignore #构建 gitbook build 创建远程分支gh-pages分支.并与本地静态资源仓库matser分支关联 cd _book git init git remote add origin git@github.com:xiaodulala/gitbook-note.git git push --force --quiet \"git@github.com:xiaodulala/gitbook-note.git\" master:gh-pages 以上操作后,我们可以在仓库设置中的page页面查看访问地址。 到目前为止,是我们手动构建的。接着要把构建并发布自动化。使用github actions. github actions配置 github actions 是github上用来持续集成和部署的功能。 每次持续继承偶读需要拉取代码、跑测试用例、合并分支、服务部署和发布等操作。github就把这些操作称为actions. github允许开发者把每个操作写成独立的脚本，存放到代码仓库里。供其他人引用。所以，当我们的项目需要使用github actions时，就不需要编写复杂的从0开始的脚本。我们可以直接引用别人写好的actions. github actions 官方市场 gitbook的发布我选用了 这一个插件。 工作流文件如下: name: Build and Publish My GitBook on: workflow_dispatch: push: branches: - master jobs: build: name: Build Gitbook runs-on: ubuntu-latest steps: # Check out the repo first - name: Checkout code uses: actions/checkout@v2 # Run this action to publish gitbook - name: Publish uses: tuliren/publish-gitbook@v1.0.0 with: # specify either github_token or personal_token github_token: ${{ secrets.GITHUB_TOKEN }} # personal_token: ${{ secrets.PERSONAL_TOKEN }} 这样，我们就可以在本地推送源文件后，自动发布了。你可以在github的action选项中查看构建过程和结果。 Copyright © Du Yong all right reserved，powered by Gitbook该文件修订时间： 2021-11-15 03:16:10 "}}